<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="favicon.png" type="image/png" />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>MalScape</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.26.0/cytoscape.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; padding: 0; font-family: 'Inter', sans-serif; color: #333; background-color: #f8f9fa; overflow-x: hidden; }
        body { display: flex; }

        #legend-container {
            width: 220px;
            background-color: #fff;
            border-right: 1px solid #dee2e6;
            padding: 16px 12px;
            height: 100vh;
            overflow-y: auto;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            position: fixed;
            left: -220px; /* Initially hidden */
            top: 0;
            z-index: 1050;
            transition: left 0.3s ease;
        }
        #legend-container.visible {
            left: 0;
        }

        #sidebar {
            width: 0; /* Initially hidden */
            height: 100vh;
            background-color: #f1f3f5;
            border-right: 1px solid #dee2e6;
            padding: 0;
            overflow-x: hidden;
            overflow-y: auto;
            transition: width 0.3s ease, padding 0.3s ease, left 0.3s ease, background-color 0.3s ease;
            position: fixed;
            top: 0;
            left: 0; /* Will be adjusted by legend visibility */
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            z-index: 1100;
            display: flex;
            flex-direction: column;
        }
        #sidebar.open {
            width: 500px;
            padding: 20px;
            left: 220px; /* When legend is visible */
        }
        #sidebar-content {
            opacity: 0;
            transition: opacity 0.3s ease 0.1s;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        #sidebar.open #sidebar-content {
            opacity: 1;
            overflow: visible;
        }
        #sidebar-cy {
            width: 100%;
            height: 40%; /* Initial height, can be overridden in fullscreen */
            min-height: 250px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            background-color: #fff;
            margin-top: 10px;
            flex-shrink: 0;
        }

        #sidebar-toggle {
            position: fixed;
            top: 50%;
            left: 0px; /* Start at edge */
            transform: translateY(-50%);
            z-index: 1200;
            background-color: #4299e1;
            color: white;
            border: none;
            padding: 15px 8px;
            border-radius: 0 6px 6px 0;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            box-shadow: 1px 1px 4px rgba(0,0,0,0.2);
            transition: background-color 0.2s ease, left 0.3s ease;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }
        #sidebar-toggle:hover {
            background-color: #3182ce;
        }

        #main-container {
            flex: 1;
            padding: 24px;
            height: 100vh;
            overflow-y: auto;
            transition: margin-left 0.3s ease;
            margin-left: 0px; /* Adjusted by JS based on sidebar state */
            padding-left: 40px; /* Space for the toggle button */
        }

        /* General Element Styling */
        h2 { color: #2c3e50; margin-top: 0; margin-bottom: 24px; font-size: 28px; font-weight: 600; border-bottom: 2px solid #4299e1; padding-bottom: 8px; display: inline-block; }
        h3 { color: #2c3e50; font-size: 16px; margin-top: 0; margin-bottom: 12px; font-weight: 600; }
        #sidebar h3 { font-size: 18px; margin-bottom: 10px; flex-shrink: 0; }

        .control-group { margin-bottom: 20px; padding: 16px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .sidebar-control {
            padding: 8px 0;
            margin-bottom: 5px;
            background: none;
            box-shadow: none;
            border-radius: 0;
            flex-shrink: 0;
        }
        .sidebar-control label {
            font-size: 13px;
            margin-right: 5px;
        }

        mark {
            background-color: yellow;
            color: black;
            padding: 0.1em;
            border-radius: 3px;
        }

        label { display: inline-block; margin-right: 8px; font-weight: 500; color: #4a5568; }
        input[type="text"], input[type="file"], input[type="range"], select, input[type="number"] {
            padding: 8px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            margin-right: 12px;
            margin-bottom: 8px;
            transition: border-color 0.2s;
            vertical-align: middle; /* Added for better alignment */
        }
        input[type="checkbox"] {
            vertical-align: middle;
            margin-right: 4px;
        }
        input[type="text"]:focus, input[type="range"]:focus, select:focus, input[type="number"]:focus {
            border-color: #4299e1;
            outline: none;
            box-shadow: 0 0 0 3px rgba(66,153,225,0.15);
        }
        button {
            background-color: #4299e1;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-right: 8px;
            vertical-align: middle; /* Added for better alignment */
        }
        button:hover { background-color: #3182ce; }

        #loadMoreBtn { display: none; margin-top: 16px; background-color: #38a169; }
        #loadMoreBtn:hover { background-color: #2f855a; }
        #cy { width: 100%; height: 600px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-top: 24px; margin-bottom: 24px; background-color: #fff; display: none; }

        /* Table Styling */
        #table-container, #sidebar-table-container {
            margin-top: 15px; /* Consistent margin */
            margin-bottom: 15px;
            border-radius: 8px; /* Consistent radius */
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: none; /* Initially hidden */
            overflow: auto; /* Changed from overflow-y for potential wide tables */
            border: 1px solid #dee2e6; /* Added border for definition */
        }
        #table-container { max-height: 300px; } /* For main table */
        #sidebar-table-container { flex-grow: 1; position: relative; } /* For sidebar table */

        #table-container table, #sidebar-table-container table { width: 100%; border-collapse: collapse; table-layout: auto; }

        #table-container th, #table-container td { padding: 12px 15px; border-bottom: 1px solid #e9ecef; text-align: left; white-space: nowrap; }

        #sidebar-table-container th {
            background-color: #f1f3f5;
            padding: 8px 10px;
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 1;
            border-bottom: 2px solid #dee2e6;
            font-weight: 600;
            white-space: nowrap;
            font-size: 11px;
        }
        #sidebar-table-container td {
            padding: 8px 10px;
            white-space: normal;
            word-break: break-word;
            border: none;
            border-bottom: 1px solid #e9ecef;
            vertical-align: top;
            line-height: 1.4;
            font-size: 11px;
        }
        #sidebar-table-container tr:last-child td { border-bottom: none; }
        #sidebar-table-container tbody tr:nth-child(even) { background-color: #f8f9fa; }
        #sidebar-table-container tbody tr:hover { background-color: #e9ecef; cursor: pointer; }
        #sidebar-table-container th, #sidebar-table-container td { min-width: 120px; word-break: break-word; } /* Adjusted min-width */


        #table-pagination, #sidebar-table-pagination { display: none; margin-top: 8px; text-align: center; flex-shrink: 0;}
        #table-pagination input, #sidebar-table-pagination input { width: 60px; text-align: center; }
        #sidebar-table-pagination button { padding: 4px 8px; font-size: 12px; }
        #sidebar-table-pagination input { width: 45px; font-size: 12px; padding: 4px 6px; }


        #sidebar-table-no-results { text-align: center; padding: 10px; color: #6c757d; display: none; }
        #tooltip { 
            position: absolute; 
            display: none; 
            background: rgba(255, 255, 255, 0.95); 
            border-radius: 4px; 
            padding: 8px 12px; 
            font-size: 13px; 
            color: #2d3748; 
            pointer-events: none; 
            z-index: 2100; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.15); 
            max-width: 300px; 
            line-height: 1.5; 
            border: 1px solid #dee2e6; 
        }        
        .color-box { display: inline-block; width: 12px; height: 12px; vertical-align: middle; margin-right: 4px; border: 1px solid #ccc; }

        /* Legend Styling */
        #legend { font-size: 12px; line-height: 1.4; table-layout: fixed; width: 100%;}
        #legend th, #legend td { padding: 4px 6px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
        #legend td:first-child, #legend th:first-child { width: 45%; }
        #legend td:nth-child(2), #legend th:nth-child(2) { width: 25%; }
        #legend td:last-child, #legend th:last-child { width: 30%; text-align: right;}

        #backToHeatmap { margin: 20px 0; padding: 8px 16px; font-size: 14px; display: none; }

        /* Edge Filter Panel */
        #edgeFilterPanel { position: absolute; top: 80px; right: 20px; width: 320px; padding: 12px; background-color: #fff; border: 1px solid #e2e8f0; border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); display: none; z-index: 999; }
        #edgeFilterPanel h4 { margin-top: 0; margin-bottom: 8px; font-size: 16px; font-weight: 600; color: #2c3e50; }
        #edgeFilterPanel label { display: block; margin-top: 8px; font-weight: 500; color: #4a5568; }
        #edgeFilterPanel input { margin-bottom: 8px; width: 100%; }

        /* Loading Overlay */
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.8); z-index: 3000; display: none; align-items: center; justify-content: center; flex-direction: column; }
        .spinner { border: 8px solid #f3f3f3; border-top: 8px solid #4299e1; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin-bottom: 16px; }
        .loading-text { font-size: 18px; color: #333; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Sidebar Specific Buttons */
        #resetSidebarBtn { background-color: #6c757d; margin-top: 5px; margin-bottom: 10px; width: 100%; flex-shrink: 0; }
        #resetSidebarBtn:hover { background-color: #5a6268; }
        #sidebar-table-search-container { padding: 10px 0 5px 0; flex-shrink: 0; display: none; }
        #sidebar-table-search-container label { font-weight: 600; font-size: 13px; margin-right: 5px; }
        #sidebarTableSearchInput { width: calc(100% - 100px); padding: 5px 8px; font-size: 12px; margin-right: 0; }


        /* Sidebar Fullscreen Styles */
        #sidebarFullscreenBtn {
            position: absolute;
            top: 5px;
            right: 10px;
            width: auto;
            padding: 4px 8px;
            font-size: 18px;
            line-height: 1;
            z-index: 1150;
            background-color: #6c757d;
            color: white;
            border: 1px solid #5a6268;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            margin: 0;
        }
        #sidebarFullscreenBtn:hover { background-color: #5a6268; border-color: #4e555b; }

        #legend-container.fullscreen-active {
            display: block !important; position: fixed !important; left: 0 !important; top: 0 !important;
            height: 100vh !important; width: 220px !important;
            z-index: 1999 !important;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1); border-right: 1px solid #dee2e6;
            background-color: #fff; overflow-y: auto;
        }

        #sidebar.fullscreen {
            padding: 10px !important;
            position: fixed !important; top: 0 !important; 
            left: 220px !important;
            width: calc(100vw - 220px) !important;
            height: 100vh !important;
            border-right: none !important;
            z-index: 2000 !important;
            overflow: hidden !important;
        }
        #sidebar.fullscreen #sidebar-content {
            flex-direction: column;
            gap: 10px;
        }
        #sidebar.fullscreen #sidebar-cy {
            flex: 1 1 60%; 
            min-height: 150px !important; height: 100% !important; 
            margin-top: 0 !important; border-radius: 6px; border: 1px solid #dee2e6;
        }
        #sidebar.fullscreen #sidebar-table-container {
            flex: 1 1 40%; 
            min-height: 100px; height: 100% !important; 
            margin-top: 0 !important; display: flex !important; flex-direction: column;
            border-radius: 6px; border: 1px solid #dee2e6;
        }
        #sidebar.fullscreen #sidebar-table-container table {
            flex-grow: 1; 
            display: block; 
            overflow-y: auto;
        }
        #sidebar.fullscreen #sidebar-table-search-container { display: block !important; visibility: visible !important; padding-bottom: 10px; }
        #sidebar.fullscreen #sidebar-table-pagination { display: block !important; padding-top: 5px; }
        #sidebar.fullscreen h3,
        #sidebar.fullscreen #resetSidebarBtn,
        #sidebar.fullscreen #sidebar-info,
        #sidebar.fullscreen .sidebar-control /* Hides layout select in fullscreen */
         { display: none !important; visibility: hidden !important; }

        #sidebar.fullscreen #saveSelectionBtn {
            padding: 5px 10px;
            font-size: 12px;
            width: auto;
        }

        body.sidebar-fullscreen #main-container,
        body.sidebar-fullscreen #sidebar-toggle { display: none !important; visibility: hidden !important; }

        /* --- Dendrogram Card and Controls CSS --- */
        #dendrogramCard {
            display: none; /* Initially hidden */
            background: #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            border: 1px solid #e2e8f0;
        }

        #dendrogramCard .dendro-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        #dendrogramCard .dendro-header h3 { /* Target h3 within .dendro-header */
            margin-bottom: 0;
        }

        #dendrogramCard .dendro-header button { /* Styles for Reset Zoom button in this header */
            padding: 6px 12px;
            margin-left: auto;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            /* Ensure this doesn't conflict with general button styles by being more specific if needed */
        }
        #dendrogramCard .dendro-header button:hover {
            background-color: #5a6268;
        }

        #inline-dendrogram-container {
            margin-bottom: 10px;
            width: 100%;
            height: 400px; /* Default height, JS can override */
            overflow: hidden;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            position: relative;
        }

        #inlineDendrogramSvg {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }
        #inlineDendrogramSvg:active {
            cursor: grabbing;
        }

        #treeControls.tree-controls-sections {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 0px;
            padding-top: 10px;
            margin-top: 15px;
            border-top: 1px solid #e2e8f0;
        }

        .control-section {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            border-right: 1px solid #e2e8f0;
            flex-basis: auto; /* Let content size influence basis */
            /* flex-grow is set per child below */
        }
        .control-section:last-child {
            border-right: none;
        }

        /* Adjust flex-grow for better distribution */
        #treeControls.tree-controls-sections .control-section:nth-child(1) { /* Order Heatmap By */
            flex-grow: 3; /* Takes more relative space */
            min-width: 280px; /* Example min-width */
        }
        #treeControls.tree-controls-sections .control-section:nth-child(2) { /* Louvain Resolution */
            flex-grow: 2; /* Takes less relative space */
            min-width: 240px; /* Example min-width */
        }
        #treeControls.tree-controls-sections .control-section:nth-child(3) { /* Threshold options */
            flex-grow: 4; /* Takes most relative space */
            min-width: 320px; /* Example min-width */
        }


        .control-section label {
            margin-bottom: 0;
            white-space: nowrap;
            font-weight: 500;
            color: #4a5568;
        }

        .control-section input[type="number"],
        .control-section select {
            padding: 6px 8px; /* Consistent padding */
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            margin-bottom: 0; /* Override default if any */
            vertical-align: middle;
        }

        .control-section input[type="number"] {
            width: 70px; /* Specific width for resolution input */
        }
        .control-section input[type="range"]{ /* Specific styling for range slider in sections */
            margin-right: 5px; /* Reduce margin if needed */
            padding: 0; /* Range inputs often don't need padding */
        }
         #thresholdValue { /* For the percentage span */
            min-width: 35px;
            display: inline-block;
            text-align: right;
            font-size: 14px;
            vertical-align: middle;
        }


        .control-section input[type="checkbox"] {
            vertical-align: middle;
            margin-right: 4px;
        }
        .control-section input[type="checkbox"] + label {
            font-weight: normal;
            font-size: 13px;
            color: #4a5568; /* Ensure label color consistency */
        }

        .control-section button {
            background-color: #4299e1;
            color: white;
            border: none;
            padding: 6px 12px; /* Consistent padding */
            border-radius: 4px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-bottom: 0; /* Override default if any */
            vertical-align: middle;
        }
        .control-section button:hover {
            background-color: #3182ce;
        }
        .control-section #resetGroupingBtn {
            background-color: #f56565;
        }
        .control-section #resetGroupingBtn:hover {
            background-color: #e53e3e;
        }

        #reclusterMessage {
            color: #e53e3e;
            font-size: 13px;
            margin-top: 10px; /* Adjusted margin */
            width: 100%;
            font-weight: 500;
            min-height: 1em; /* Prevent layout shift */
        }

        /* Disabled states for controls within treeControls */
        #treeControls .control-section button:disabled,
        #treeControls .control-section input:disabled,
        #treeControls .control-section select:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        #treeControls .control-section button:disabled {
            background-color: #a0aec0 !important; /* Use important if needed to override general button style */
        }
        #treeControls .control-section button:disabled:hover {
            background-color: #a0aec0 !important;
        }
        #treeControls .control-section input:disabled {
            background-color: #e9ecef; /* Lighter background for disabled input */
        }


        /* Dendrogram SVG specific styles */
        .node--leaf circle { fill: #999; stroke: none; }
        .node--internal circle { fill: #555; stroke: none; }
        .node--group circle { fill: #a0a0a0; stroke: #555; stroke-width: 1px; }
        .link { fill: none; stroke: #ccc; stroke-width: 1.5px; }
        .node--leaf circle.highlighted { r: 6 !important; stroke: #555; stroke-width: 0.5px; /* Color set by JS */ }
        .node.grayed-out > circle { fill: #d3d3d3 !important; stroke: #bbb !important; opacity: 0.6; }
        .node.grayed-out > text { fill: #aaa !important; opacity: 0.7; }
        #threshold-bar { stroke: rgba(220, 53, 69, 0.7); stroke-width: 2; stroke-dasharray: 5 3; pointer-events: none; }
        .heatmap-cell { cursor: pointer; stroke: #fff; stroke-width: 0.2; /* Default, JS overrides */ }
        .heatmap-feature-label { font-size: 9px; fill: #333; text-anchor: end; dominant-baseline: middle; }

        /* Responsive adjustments for Dendrogram Controls */
        @media (max-width: 1200px) { /* Broader breakpoint for stacking sections earlier */
            #treeControls.tree-controls-sections {
                flex-direction: column;
                align-items: stretch;
            }
            .control-section {
                border-right: none;
                border-bottom: 1px solid #e2e8f0;
                padding: 10px;
                flex-basis: auto !important; /* Reset basis */
                flex-grow: 1 !important;    /* Allow all to grow equally when stacked */
                min-width: 0 !important;     /* Reset min-width */
                flex-wrap: wrap; /* Allow items within section to wrap */
            }
            .control-section:last-child { border-bottom: none; }
        }

        @media (max-width: 768px) {
            #dendrogramCard .dendro-header {
                flex-direction: column;
                align-items: flex-start;
            }
            #dendrogramCard .dendro-header button {
                margin-top: 10px;
                margin-left: 0;
                align-self: flex-start;
            }
            .control-section { /* Items within sections stack */
                flex-direction: column;
                align-items: flex-start;
            }
            .control-section > * {
                margin-bottom: 8px;
            }
            .control-section input[type="range"] { width: 100%; max-width: 280px; }
            .control-section select, .control-section input[type="number"], .control-section button {
                width: auto;
                min-width: 150px;
            }
            .control-section div {
                width: 100%;
            }
        }
        button:disabled {
            background-color: #ccc !important;
            color: #666 !important;
            cursor: not-allowed !important;
        }
        button#applySankeyToHeatmapBtn:not(:disabled) {
            background-color: #28a745 !important;
        }
        button#applySankeyToHeatmapBtn:not(:disabled):hover {
            background-color: #218838 !important;
        }

        #timeline-container {
            width: 100%;
            height: 100px;
            position: relative;
        }
        #timeline-container .axis .domain {
            stroke: #666;
        }
        #timeline-container .axis .tick line {
            stroke: #ccc;
        }
        #timeline-container .axis .tick text {
            fill: #444;
            font-size: 10px;
        }
        #timeline-container .context-area {
            fill: #4299e1;
            fill-opacity: 0.3;
        }
        #timeline-container .brush .selection {
            fill: #4299e1;
            fill-opacity: 0.5;
            stroke: #3182ce;
            stroke-width: 1px;
        }
        #timeline-container .brush .handle {
            fill: #f1f3f5;
            stroke: #6c757d;
            stroke-width: 1px;
        }
    </style>
</head>
<body>
  <div id="loading-overlay" title="Data is loading...">
    <div class="spinner"></div>
    <div class="loading-text">Loading, please wait...</div>
    <button id="cancelLoadingBtn" style="margin-top: 20px; padding: 8px 16px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Cancel</button>
  </div>

  <div id="legend-container" title="Shows protocol colors and statistics.">
    <div id="saved-items-section" style="margin-bottom: 20px;">
        <h3 style="font-size: 14px; margin-bottom: 8px;">Saved Items</h3>
        <ul id="saved-items-list" style="list-style-type: none; padding-left: 0; font-size: 12px; max-height: 150px; overflow-y: auto;">
            </ul>
        <p id="no-saved-items" style="font-size: 12px; color: #6c757d; text-align: center; display: none;">No items saved yet.</p>
    </div>
    <hr style="margin-bottom: 15px;"> 
    <h3 id="protocol-legend-title">Protocol Legend</h3>
    <table id="legend">
      <thead><tr><th>Protocol</th><th>Color</th><th>Process %</th></tr></thead>
      <tbody></tbody>
    </table>
    <div class="control-group sidebar-control" style="margin-top: 20px; padding: 10px 0px 5px 0px; box-shadow: none;" title="Adjust node and edge sizes in the sidebar graph.">
        <h3 style="margin-bottom: 10px; font-size: 14px;">Sidebar Graph Sizing</h3>

        <label for="sidebarNodeSizeMin" style="font-size: 12px; display: block; margin-bottom: 2px;">Min Node Size:</label>
        <input type="number" id="sidebarNodeSizeMin" placeholder="2" step="1" min="2" style="width: 90%; padding: 4px 6px; font-size: 11px; margin-bottom: 8px;">

        <label for="sidebarNodeSizeMax" style="font-size: 12px; display: block; margin-bottom: 2px;">Max Node Size:</label>
        <input type="number" id="sidebarNodeSizeMax" step="1" min="3" style="width: 90%; padding: 4px 6px; font-size: 11px; margin-bottom: 8px;">

        <label for="sidebarEdgeWidthMin" style="font-size: 12px; display: block; margin-bottom: 2px;">Min Edge Width:</label>
        <input type="number" id="sidebarEdgeWidthMin" placeholder="1" step="1" min="1" style="width: 90%; padding: 4px 6px; font-size: 11px; margin-bottom: 8px;">

        <label for="sidebarEdgeWidthMax" style="font-size: 12px; display: block; margin-bottom: 2px;">Max Edge Width:</label>
        <input type="number" id="sidebarEdgeWidthMax" placeholder="8" step="1" min="1" style="width: 90%; padding: 4px 6px; font-size: 11px; margin-bottom: 8px;">
    </div>
    
  </div>

  <button id="sidebar-toggle" title="Open/close cluster detail sidebar">&#9776;</button>

  <div id="sidebar" title="Shows detailed graph and data for selected heatmap clusters.">
      <div id="sidebar-content">
          <button id="sidebarFullscreenBtn" title="Toggle Sidebar Fullscreen">&#x2922;</button>

          <h3>Cluster Visualization</h3>
          <button id="saveSelectionBtn" title="Save current selection to Saved Items list" style="margin-bottom: 10px; width: 100%; background-color: #28a745; color: white;">Save Selection</button>
          <button id="resetSidebarBtn" title="Clear sidebar graph, table, and heatmap selections.">Reset Node Selection</button>

          <div class="control-group sidebar-control" title="Change sidebar graph layout.">
              <label for="sidebarLayoutSelect">Layout:</label>
              <select id="sidebarLayoutSelect" style="padding: 4px 8px; font-size: 12px; max-width: 150px;">
                  <option value="cose" selected>Cose (Default)</option>
                  <option value="breadthfirst">Hierarchical</option>
                  <option value="circle">Circle</option>
                  <option value="grid">Grid</option>
                  <option value="concentric">Concentric</option>
                  </select>
          </div>

          <div id="sidebar-cy-loading" style="display: none; text-align: center; margin-top: 5px; color: #6c757d;">Loading graph...</div>
          <div id="sidebar-cy" title="Interactive graph of selected cluster(s). Click nodes/edges to filter table."></div>
          <div id="sidebar-info" style="margin-top: 10px; font-size: 14px; text-align: center; flex-shrink: 0;">Click a cell on the heatmap to add its cluster. Click nodes or edges in the graph to highlight and filter the table below.</div>

          <div id="sidebar-table-search-container" title="Filter sidebar table rows.">
              <label for="sidebarTableSearchInput">Search Table:</label>
              <input type="text" id="sidebarTableSearchInput" placeholder="Enter keywords...">
          </div>

          <div id="sidebar-table-loading" style="display: none; text-align: center; margin-top: 20px; color: #6c757d;">Loading table...</div>
          <div id="sidebar-table-container" title="Detailed connection data for selected cluster/node/edge(s). Click row to highlight edge.">
             <p id="sidebar-table-no-results">No rows match your search criteria.</p>
             </div>
          <div id="sidebar-table-pagination" title="Navigate sidebar table pages.">
              <span>Page <input type="number" id="sidebarCurrentPageInput" value="1" min="1"> of <span id="sidebarTotalPages">?</span></span>
              <button id="sidebarGoPageBtn">Go</button>
          </div>
      </div>
  </div>

  <div id="main-container">
    <h2>MalScape</h2>
    <div id="topControls">
        <div style="margin-bottom: 16px; background: #fff; padding: 12px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <label for="fileInput"><strong>Upload Parquet File:</strong></label>
            <input type="file" id="fileInput" accept=".parquet" title="Select Parquet file to visualize.">
            <button id="downloadProcessedDataBtn" title="Download currently loaded data as CSV.">Download Processed Data (CSV)</button>
            <button id="showPacketSimilarityBtn" title="Visualize Louvain IP Communities" style="margin-left: 8px;">Show Community IP Graph</button>
            <button id="showSankeyBtn" title="Visualize data flows with Sankey diagram" style="margin-left: 8px;">Show Sankey Diagram</button>
        </div>
        <div id="csvProcessTime" style="font-size: 0.75em; color: #555; margin-top: -12px; margin-bottom: 12px; padding-left: 2px; text-align: left; display: none; height: 1.2em;"></div>
      <div class="control-group" title="Filter data displayed in heatmap.">
        <label for="rowOrderSelect">Order Cells By:</label>
        <select id="rowOrderSelect" title="Order heatmap rows by metric value."> <option value="descending">Descending</option> <option value="ascending">Ascending</option> </select>
        <label for="minSourceAmtFilter">Min Src:</label>
        <input type="number" id="minSourceAmtFilter" placeholder="1" step="1" style="width:60px;" title="Minimum source appearances.">
        <label for="maxSourceAmtFilter">Max Src:</label>
        <input type="number" id="maxSourceAmtFilter" placeholder="Inf" step="1" style="width:60px;" title="Maximum source appearances.">
        <label for="minDestinationAmtFilter">Min Dst:</label>
        <input type="number" id="minDestinationAmtFilter" placeholder="1" step="1" style="width:60px;" title="Minimum destination appearances.">
        <label for="maxDestinationAmtFilter">Max Dst:</label>
        <input type="number" id="maxDestinationAmtFilter" placeholder="Inf" step="1" style="width:60px;" title="Maximum destination appearances.">
        
        <label for="payloadSearch" style="display:none;">Payload:</label>
        <input type="text" id="payloadSearch" placeholder="Keyword" style="width:100px; display:none;" title="Filter by payload keyword (disabled for current CSV format).">
        
        <label for="sourceFilter">Src IP:</label>
        <input type="text" id="sourceFilter" placeholder="IP" style="width:100px;" title="Filter by source IP/subnet.">
        <label for="destinationFilter">Dst IP:</label>
        <input type="text" id="destinationFilter" placeholder="IP" style="width:100px;" title="Filter by destination IP/subnet.">
        <label for="protocolFilter">Proto:</label>
        <input type="text" id="protocolFilter" placeholder="TCP" style="width:60px;" title="Filter by protocol name.">
        
        <label for="entropyMinFilter" style="display:none;">Min Ent:</label> <input type="number" id="entropyMinFilter" placeholder="0.0" step="0.1" style="width:60px; display:none;" title="Minimum payload entropy.">
        <label for="entropyMaxFilter" style="display:none;">Max Ent:</label> <input type="number" id="entropyMaxFilter" placeholder="Inf" step="0.1" style="width:60px; display:none;" title="Maximum payload entropy.">
        
        <button id="applyFiltersBtn" style="margin-left: 10px;" title="Apply selected filters to heatmap.">Apply Filters</button>
      </div>
    </div>

    <div id="timeline-card" style="display: none; background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 15px 20px; border-radius: 12px; margin: 20px 0; border: 1px solid #e2e8f0;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin-top:0; margin-bottom: 5px;">Time Window Selector</h3>
            
            <div>
                <button id="applyTimelineBtn" style="padding: 4px 8px; font-size: 12px; background-color: #28a745;">Apply</button>
                <button id="resetTimelineBtn" style="padding: 4px 8px; font-size: 12px; background-color: #6c757d;">Reset</button>
            </div>
            </div>
        <div id="timeline-container"></div>
    </div>

    <div id="dendrogramCard" style="display: none; background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 20px; border-radius: 12px; margin: 20px 0; border: 1px solid #e2e8f0;">
        <div class="dendro-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
            <h3>Hierarchical Cluster Tree</h3>
            <button onclick="resetInlineZoom()" style="padding: 6px 12px; background-color: #6c757d; color: white; border: none; border-radius: 4px; font-family: 'Inter', sans-serif; font-size: 14px; font-weight: 500; cursor: pointer;">Reset Zoom</button>
        </div>

        <div id="dendrogramMetaDataLine" style="font-size: 12px; color: #555; margin-left: 0px; line-height: 1.4; font-weight: normal; margin-bottom: 10px; padding-left: 2px;">
            </div>
        
        <span id="treeInfoSpan" style="display:none;"></span>
        <span id="timeInfoSpan" style="display:none;"></span>
        <span id="packetCountSpan" style="display:none;"></span>

        <div id="inline-dendrogram-container" style="margin-bottom: 10px; width: 100%; height: 400px; overflow: hidden; border: 1px solid #dee2e6; border-radius: 6px; position: relative;">
            <svg id="inlineDendrogramSvg" style="width: 100%; height: 100%; display: block; cursor: grab;"></svg>
        </div>

        <div id="treeControls" class="tree-controls-sections" style="margin-top: 15px;">
            <div class="control-section">
                <label for="dendrogramSortMetricSelect">Order Heatmap By:</label>
                <select id="dendrogramSortMetricSelect" style="padding: 6px 8px; margin-bottom: 0;">
                    <option value="Default" selected>Default (Structure)</option>
                    <optgroup label="Basic Counts">
                        <option value="Count">Count</option>
                        <option value="Unique IPs">Unique IPs</option>
                        <option value="Unique Sources">Unique Sources</option>
                        <option value="Unique Destinations">Unique Destinations</option>
                    </optgroup>
                    <optgroup label="Packet/Payload Size">
                        <option value="Length">Packet Length</option>
                        <option value="Len">Payload Length</option>
                        <option value="Payload Size Variance">Payload Size Variance</option>
                    </optgroup>
                    <optgroup label="Timing/Rate">
                        <option value="Start Time">Start Time</option>
                        <option value="Duration">Duration</option>
                        <option value="Average Inter-Arrival Time">Avg Inter-Arrival Time</option>
                        <option value="Packets per Second">Packets per Second</option>
                    </optgroup>
                    <optgroup label="Data Volume">
                        <option value="Total Data Sent">Total Data Sent</option>
                    </optgroup>
                    <optgroup label="TCP Flags">
                        <option value="% SYN packets">% SYN packets</option>
                        <option value="% RST packets">% RST packets</option>
                        <option value="% ACK packets">% ACK packets</option>
                        <option value="% PSH packets">% PSH packets</option>
                    </optgroup>
                </select>
                <div style="display: inline-block; margin-left: 5px; vertical-align: middle;">
                    <input type="checkbox" id="reorderTreeCheckbox" style="vertical-align: middle; margin-right: 4px;">
                    <label for="reorderTreeCheckbox" style="font-weight: normal; font-size: 13px;">Reorder Tree Structure</label>
                </div>
            </div>

            <div class="control-section">
                <label for="resolutionInput">Louvain Resolution:</label>
                <input type="number" id="resolutionInput" step="0.1" min="0.1" placeholder="2.5" style="margin-bottom: 0; vertical-align: middle; width: 70px; padding: 6px 8px;">
                <button onclick="reclusterAndRedraw()" style="padding: 6px 12px;">Apply Resolution</button>
            </div>

            <div class="control-section">
                <label for="thresholdSlider">Visual Threshold:</label>
                <input type="range" id="thresholdSlider" min="0" max="100" value="100" style="width: 150px; vertical-align: middle;">
                <span id="thresholdValue" style="min-width: 35px; display: inline-block; text-align: right; font-size: 14px; vertical-align: middle;">100%</span>
                <button id="applyThresholdBtn" style="padding: 6px 12px;" title="Group clusters below the current threshold line">Apply Threshold</button>
                <button id="resetGroupingBtn" style="padding: 6px 12px; background-color: #f56565;" title="Revert tree to its original state before thresholding">Reset Grouping</button>
            </div>
        </div>
        
        <div id="reclusterMessageContainer" style="display: flex; align-items: center; gap: 10px; margin-top: 10px; width: fit-content;">
            <div id="reclusterMessage" style="color: #e53e3e; font-size: 13px; font-weight: 500; min-height: 1em;"></div>
            <button id="acknowledgeNewClustersBtn" style="display: none; padding: 4px 8px; font-size: 12px; background-color: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Acknowledge</button>
        </div>
    </div>

    <div id="packetSimilarityCard" style="display:none; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-top: 20px;">
        <h3>Louvain Community IP Graph</h3>
        <div style="margin-bottom:10px;">
            <button id="refreshIpGraphBtn" style="margin-left: 10px;">Refresh Graph</button>
            </div>
        <div id="louvain-ip-graph-container" style="width: 100%; height: 600px; position: relative; border: 1px solid #ccc; margin-top:10px; background-color: #fdfdfd;">
            </div>
        <div id="packetSimilarityLoading" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.8); display: none; align-items: center; justify-content: center; flex-direction: column;">
            <div class="spinner" style="border: 4px solid #f3f3f3; border-top: 4px solid #4299e1; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 10px;"></div>
            Loading IP Community Graph... </div>
    </div>

    <div id="sankeyCard" style="display:none; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-top: 20px;">
        <h3>Sankey Diagram</h3>
            <div style="margin-bottom:10px;">
                <div style="margin-bottom: 8px;"><strong>Select dimensions:</strong></div>
                <div id="sankeyDimensionCheckboxes" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom:10px;">
                    </div>
                <button id="applySankeyToHeatmapBtn" disabled style="margin-top: 10px; margin-bottom: 10px; background-color: #6c757d;">
                    Apply Sankey Selection to Heatmap
                </button>
                <button id="revertSankeyFilterBtn" disabled title="Revert the heatmap to its state before the Sankey filter was applied" style="margin-top: 10px; margin-bottom: 10px; background-color: #6c757d;">
                    Revert Sankey Filter
                </button>
            </div>
            <div id="sankey-diagram-container" style="width: 100%; height: 700px; position: relative; border: 1px solid #ccc; margin-top:10px; background-color: #fdfdfd; overflow: auto;">
                </div>
        <div id="sankeyLoading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255,255,255,0.8); display: none; align-items: center; justify-content: center; flex-direction: column; padding: 20px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.2); z-index:10;">
            <div class="spinner" style="border: 4px solid #f3f3f3; border-top: 4px solid #4299e1; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 10px;"></div>
            Loading Sankey Diagram...
        </div>
    </div>

    <div id="table-search-container" style="display:none; margin-bottom: 12px; margin-top: 24px;" title="Search main table payload.">
      <label for="tableSearchInput"><strong>Search Payload:</strong></label>
      <input type="text" id="tableSearchInput" placeholder="Enter keyword..." style="padding: 6px 10px; width: 250px;">
    </div>
    <div id="table-container" title="Main connection data table (used in network graph view)."></div>
    <div id="table-pagination" title="Navigate main table pages.">
      <span>Page <input type="number" id="currentPageInput" value="1" min="1" style="width:60px;"> of <span id="totalPages">?</span></span>
      <button id="goPageBtn">Go</button>
    </div>
    <div style="margin-top: 20px;">
        <button id="loadMoreBtn" title="Load more data (not implemented).">Load More</button>
        <button id="refreshNetworkBtn" style="display: none; background-color:#4299e1; color:white; margin-left: 8px;" title="Refresh network graph (not implemented).">Refresh Network</button>
    </div>
    <div id="cy" title="Main network graph view (not fully implemented)."></div>
  </div>

  <div id="edgeFilterPanel" title="Filter edges in main network graph.">
    <h4>Edge Filter</h4>
    <label for="edgeFilterSource">Source (partial ok):</label> <input type="text" id="edgeFilterSource">
    <label for="edgeFilterDestination">Destination (partial ok):</label> <input type="text" id="edgeFilterDestination">
    <label for="edgeFilterProtocol">Protocol (partial ok):</label> <input type="text" id="edgeFilterProtocol">
    <label for="edgeFilterWeight">Edge Weight (e.g. >=1000):</label> <input type="text" id="edgeFilterWeight" placeholder=">=1000">
    <label for="edgeFilterProcessCount">Process Count (e.g. >5):</label> <input type="text" id="edgeFilterProcessCount" placeholder=">=5">
    <button id="applyEdgeFilterBtn" title="Apply edge filters.">Filter Edges</button> <button id="clearEdgeFilterBtn" title="Remove edge filters.">Clear Filter</button>
  </div>

  <div id="tooltip" title="Hover details appear here."></div>

  <script>
    //GLOBAL
    let API_BASE_URL;
    if (window.location.hostname === "127.0.0.1" && 
        (window.location.port === "5500" || window.location.port === "5501" || window.location.port === "5502" /* Add other common Live Server ports if needed */) &&
        window.location.port !== "5000") {
        API_BASE_URL = 'http://127.0.0.1:5000'; // Manually target Flask server
        console.log("Detected local Live Server, API_BASE_URL forced to Flask default:", API_BASE_URL);
    } else {
        API_BASE_URL = window.location.origin; // Standard behavior for deployment or when served by Flask
        console.log("Using window.location.origin for API_BASE_URL:", API_BASE_URL);
    }

    const DEFAULT_SANKEY_DIMENSIONS = [
        { value: "Protocol", label: "Protocol", defaultChecked: true },
        { value: "SourceClassification", label: "Source Type", defaultChecked: true },
        { value: "DestinationClassification", label: "Dest. Type", defaultChecked: true },
        { value: "SourcePort_Group", label: "Src Port Grp", defaultChecked: true },
        { value: "DestinationPort_Group", label: "Dst Port Grp", defaultChecked: true },
        { value: "Len_Group", label: "Pkt Len Grp", defaultChecked: true },
        { value: "Anomaly", label: "Anomaly", defaultChecked: true },
        { value: "ClusterID", label: "Cluster ID", defaultChecked: false }
    ];
    window.currentSankeyDimensionsOrder = [...DEFAULT_SANKEY_DIMENSIONS];
    window.sankeyMatchingClusterIds = new Set();

    const DEFAULT_UNKNOWN_COLOR = '#cccccc';
    const SELECTED_EDGE_COLOR = '#ff0000';
    const SELECTED_NODE_COLOR = '#ff0000';
    const SELECTED_EDGE_WIDTH = 3.5;
    const SELECTED_EDGE_ZINDEX = 999;

    let sankeyDiagramRendered = false;
    let globalAbortController = new AbortController();
    let louvainIpCy = null;
    window.currentGroupingApplied = false;
    window.lastAppliedThreshold = 100;
    window.originalTreeData = null;
    window.currentGrouping = null;
    let previousClusterCount = null;
    let previousClusterHash = null;
    let currentDendrogramHeight = 400;
    window.lastTreeData = null;
    window.inlineZoom = null;
    let initialTreeTransform = d3.zoomIdentity;
    const margin = { top: 30, right: 30, bottom: 120, left: 30 };
    window.fullHeatmapData = {};
    window.heatmapSortOrders = {};
    const metrics = [
        { label: "Count", value: "count" }, { label: "Unique IPs", value: "Unique IPs" },
        { label: "Unique Sources", value: "Unique Sources" }, { label: "Unique Destinations", value: "Unique Destinations" },
        { label: "Packet Length", value: "Length" }, { label: "Payload Length", value: "Len" },
        { label: "Payload Size Variance", value: "Payload Size Variance" },
        { label: "Start Time", value: "Start Time" },
        { label: "Duration", value: "Duration" },
        { label: "Average Inter-Arrival Time", value: "Average Inter-Arrival Time" },
        { label: "Packets per Second", value: "Packets per Second" },
        { label: "Total Data Sent", value: "Total Data Sent" },
        { label: "% SYN packets", value: "% SYN packets" }, { label: "% RST packets", value: "% RST packets" },
        { label: "% ACK packets", value: "% ACK packets" }, { label: "% PSH packets", value: "% PSH packets" }
    ];

    var currentDisplayableTimeInfo = {
        start: "Start: N/A",
        end: "End: N/A",
        duration: "Duration: N/A",
        isSet: false
    };

    let protocolColorMap = {};
    let globalCy;
    let sidebarCy;
    let currentClusterID = null;
    let currentSidebarTableClusterId = null;
    const TABLE_PAGE_SIZE = 30;
    const heatmapCellWidth = 2;
    const heatmapCellHeight = 15;
    let tooltip;
    let clusterHighlightColors = new Map();
    let addedSidebarClusters = new Set();
    let selectedSidebarEdges = new Set();
    let selectedSidebarNodes = new Set();
    let previousClusterIdsBeforeRecluster = new Set(); //previous clusters before applying new louvain resolution
    let currentNewClusterIds = new Set();
    let selectedNodeId = null;
    let sidebarTableMode = 'cluster';
    let isSidebarOpen = false;
    const sidebarWidth = 500;
    const legendWidth = 220;
    
    window.activeSankeyNodeFilter = null;
    window.allClusterIdsMasterList = [];
    window.currentTimeSelection = null;
    
    const sidebar = document.getElementById('sidebar');
    const sidebarToggleBtn = document.getElementById('sidebar-toggle');
    const mainContainer = document.getElementById('main-container');
    const legendContainer = document.getElementById('legend-container');
    const resetSidebarBtn = document.getElementById('resetSidebarBtn');
    const sidebarTableContainer = document.getElementById('sidebar-table-container');
    const sidebarTablePagination = document.getElementById('sidebar-table-pagination');
    const sidebarGoPageBtn = document.getElementById('sidebarGoPageBtn');
    const sidebarSearchContainer = document.getElementById('sidebar-table-search-container');
    const sidebarSearchInput = document.getElementById('sidebarTableSearchInput');
    const sidebarInfoDiv = document.getElementById('sidebar-info');
    const sidebarFullscreenBtn = document.getElementById('sidebarFullscreenBtn');
    let isSidebarFullscreen = false;
    let savedItems = [];
    const MAX_SAVED_ITEMS = 10;


    const sidebarLayoutOptions = {
        cose: {
            name: 'cose', animate: true, animationDuration: 500, padding: 30,
            idealEdgeLength: 100, nodeRepulsion: node => node.degree() * 15000,
            edgeElasticity: edge => 100, gravity: 60, numIter: 1000,
            initialTemp: 200, coolingFactor: 0.95, minTemp: 1.0, fit: true
        },
        breadthfirst: {
            name: 'breadthfirst', directed: true, padding: 20, circle: false,
            grid: false, spacingFactor: 1.4, avoidOverlap: true,
            nodeDimensionsIncludeLabels: false, roots: undefined,
            animate: true, animationDuration: 500, fit: true
        },
        circle: {
            name: 'circle', padding: 25, avoidOverlap: true,
            nodeDimensionsIncludeLabels: false, spacingFactor: 1.2, radius: undefined,
            startAngle: 3/2 * Math.PI,
            animate: true, animationDuration: 500, fit: true
        },
        grid: {
            name: 'grid', padding: 25, avoidOverlap: true,
            nodeDimensionsIncludeLabels: false, spacingFactor: 1,
            rows: undefined, cols: undefined,
            position: function( node ){},
            animate: true, animationDuration: 500, fit: true
        },
        concentric: {
            name: 'concentric', fit: true, padding: 30, startAngle: 3 / 2 * Math.PI,
            sweep: undefined, clockwise: true, equidistant: false,
            minNodeSpacing: 20, avoidOverlap: true, nodeDimensionsIncludeLabels: false,
            concentric: function( node ){ return node.degree(); },
            levelWidth: function( nodes ){ return nodes.maxDegree() / 4; },
            animate: true, animationDuration: 500
        }
    };

    function applySidebarLayout() {
        if (!sidebarCy) {
            console.log("Sidebar graph not initialized yet.");
            return;
        }
        const selectedLayoutName = document.getElementById('sidebarLayoutSelect').value;
        const layoutConfig = sidebarLayoutOptions[selectedLayoutName];

        if (!layoutConfig) {
            console.error(`Layout configuration for '${selectedLayoutName}' not found.`);
            return;
        }

        console.log(`Applying sidebar layout: ${selectedLayoutName}`);
        let layout = sidebarCy.layout(layoutConfig);
        layout.run();
    }

    function resetHeatmapHighlights() {
        // Select all heatmap cells within the dendrogram SVG
        const cells = d3.selectAll("#inlineDendrogramSvg .heatmap-cell");

        cells.each(function() {
            const cell = d3.select(this);
            // Get the original fill color stored when the cell was first drawn
            const originalFill = cell.attr("data-original-fill");
            const defaultStrokeColor = '#fff';
            const defaultStrokeWidth = 0.2;

            if (originalFill) {
                // Revert to the original color and default stroke
                cell.transition().duration(150)
                    .attr("fill", originalFill)
                    .style("stroke", defaultStrokeColor)
                    .style("stroke-width", defaultStrokeWidth);
            }
        });
        console.log("Heatmap cell highlights reset on client-side.");
    }

    function toggleSidebar(forceOpen = null) {
     const shouldBeOpen = forceOpen !== null ? forceOpen : !isSidebarOpen;

     if (shouldBeOpen) {
         if (!isSidebarOpen) {
             legendContainer.classList.add('visible');
             sidebar.classList.add('open');
             isSidebarOpen = true;
             sidebarToggleBtn.innerHTML = '&times;';
             sidebarToggleBtn.style.left = `${legendWidth + sidebarWidth}px`;
             mainContainer.style.marginLeft = `${legendWidth + sidebarWidth}px`;
             setTimeout(() => {
                 if (sidebarCy) {
                     sidebarCy.resize();
                     applySidebarLayout();
                     sidebarCy.fit(null, 30);
                 }
             }, 350);
         }
     } else {
          if (isSidebarOpen) {
             legendContainer.classList.remove('visible');
             sidebar.classList.remove('open');
             isSidebarOpen = false;
             sidebarToggleBtn.innerHTML = '&#9776;';
             sidebarToggleBtn.style.left = `0px`;
             mainContainer.style.marginLeft = `0px`;
          }
     }
 }

    resetSidebarBtn.addEventListener('click', () => {
        console.log("Resetting sidebar view and heatmap highlights.");
        clearSidebarVisualization();
        updateLegend();
        selectedNodeId = null;
        document.getElementById('sidebarLayoutSelect').value = 'cose';
    });

    function showSidebarLoading(isLoadingGraph, isLoadingTable) {
        document.getElementById('sidebar-cy-loading').style.display = isLoadingGraph ? 'block' : 'none';
        document.getElementById('sidebar-table-loading').style.display = isLoadingTable ? 'block' : 'none';
        const showInfo = !isLoadingGraph && !isLoadingTable && (!sidebarCy || sidebarCy.elements().length === 0) && selectedSidebarEdges.size === 0 && selectedNodeId === null;
         sidebarInfoDiv.style.display = showInfo ? 'block' : 'none';
    }

    function filterSidebarTable() {
        // This function now triggers a reload of the table from the backend.
        const searchQuery = sidebarSearchInput.value || "";
        const page = 1; // Always reset to page 1 for a new search

        if (sidebarTableMode === 'cluster' && currentSidebarTableClusterId) {
            loadSidebarClusterTable(currentSidebarTableClusterId, page, searchQuery);
        } else if (sidebarTableMode === 'edges') {
            let edgeList = [];
            if (selectedSidebarNodes.size > 0 && sidebarCy) {
                 selectedSidebarNodes.forEach(nodeId => {
                    const node = sidebarCy.getElementById(nodeId);
                    if(node && node.length > 0) {
                        node.connectedEdges().forEach(edge => {
                           edgeList.push({
                                source: edge.data('source'),
                                destination: edge.data('target'),
                                protocol: edge.data('Protocol')
                           });
                        });
                    }
                 });
                 edgeList = Array.from(new Set(edgeList.map(JSON.stringify)), JSON.parse);
            } else if (selectedSidebarEdges.size > 0) {
                edgeList = Array.from(selectedSidebarEdges).map(key => {
                    const parts = key.split('|');
                    return { source: parts[0], destination: parts[1], protocol: parts[2] };
                });
            }

            if (edgeList.length > 0) {
                loadSidebarMultiEdgeTable(edgeList, page, searchQuery);
            } else {
                sidebarTableContainer.innerHTML = '<p style="padding: 10px; text-align: center;">Select a node or edge to search.</p>';
            }
        }
    }

    function handleSidebarTableRowClick(event) {
        if (!sidebarCy || event.target.tagName !== 'TD') {
            return;
        }

        const row = event.target.closest('tr');
        if (!row || !row.parentElement || row.parentElement.tagName !== 'TBODY') {
             console.log("Clicked outside table body row.");
             return;
        }

        const table = row.closest('table');
        if (!table) return;

        const headerCells = Array.from(table.querySelectorAll('thead th'));
        const dataCells = Array.from(row.querySelectorAll('td'));

        let sourceIndex = -1;
        let destIndex = -1;
        let protocolIndex = -1;

        headerCells.forEach((th, index) => {
            const headerText = th.textContent.trim();
            if (headerText === 'Source') sourceIndex = index;
            else if (headerText === 'Destination') destIndex = index;
            else if (headerText === 'Protocol') protocolIndex = index;
        });

        if (sourceIndex === -1 || destIndex === -1 || protocolIndex === -1) {
            console.error("Could not find Source, Destination, or Protocol columns in the sidebar table header.");
            return;
        }

        const source = dataCells[sourceIndex]?.textContent.trim();
        const destination = dataCells[destIndex]?.textContent.trim();
        const protocol = dataCells[protocolIndex]?.textContent.trim();

        if (!source || !destination || !protocol) {
            console.error("Could not extract valid source, destination, or protocol from table row.", { source, destination, protocol });
            return;
        }

        console.log(`Table row clicked. Finding edge: ${source} -> ${destination} [${protocol}]`);

        const edgeSelector = `edge[source = "${source}"][target = "${destination}"][Protocol = "${protocol}"]`;
        const edgeToSelect = sidebarCy.elements(edgeSelector);

        if (edgeToSelect.length > 0) {
            console.log("Edge found:", edgeToSelect.id());
            deselectCurrentNode();

            sidebarCy.edges().filter(edge => edge !== edgeToSelect.first()).forEach(edge => {
                 selectedSidebarEdges.delete(`${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`);
                 const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                 const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                 edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
                 edge.unselect();
            });

            const targetEdge = edgeToSelect.first();
            const edgeKey = `${source}|${destination}|${protocol}`;
            selectedSidebarEdges.add(edgeKey);
            targetEdge.style({
                 'line-color': SELECTED_EDGE_COLOR,
                 'target-arrow-color': SELECTED_EDGE_COLOR,
                 'width': SELECTED_EDGE_WIDTH,
                 'z-index': SELECTED_EDGE_ZINDEX
            });
            sidebarCy.elements().unselect();
            targetEdge.select();

            sidebarCy.animate({
                fit: {
                    eles: targetEdge.union(targetEdge.connectedNodes()),
                    padding: 70
                },
                duration: 400
            });
             updateSidebarTableForSelectedEdges();

        } else {
            console.warn(`Edge not found in sidebar graph for: ${source} -> ${destination} [${protocol}]`);
        }
    }

    function clearSidebarVisualization() {
        if (sidebarCy) {
            sidebarCy.destroy();
            sidebarCy = null;
        }
        document.getElementById('sidebar-cy').innerHTML = '';
        addedSidebarClusters.clear();
        selectedSidebarEdges.clear();
        selectedNodeId = null;
        sidebarTableMode = 'cluster';
        currentSidebarTableClusterId = null;
        sidebarTableContainer.innerHTML = '<p id="sidebar-table-no-results" style="display: none; text-align: center; padding: 10px; color: #6c757d;">No rows match your search criteria.</p>';
        sidebarTableContainer.style.display = 'none';
        sidebarTablePagination.style.display = 'none';
        sidebarSearchContainer.style.display = 'none';
        if (sidebarSearchInput) sidebarSearchInput.value = '';
        document.getElementById('sidebar-cy-loading').style.display = 'none';
        document.getElementById('sidebar-table-loading').style.display = 'none';
        sidebarInfoDiv.innerHTML = 'Click a cell on the heatmap to add its cluster. Click nodes or edges in the graph to highlight and filter the table below.';
        sidebarInfoDiv.style.display = 'block';

        clusterHighlightColors.clear(); // Clear the central selection state map
        try {
            const svgContent = d3.select("#inlineDendrogramSvg g"); // Select the content group
            if (!svgContent.empty()) {

                highlightTreeClusters(); // Calling with no arguments resets fills

                const defaultStrokeColor = '#fff'; // Define or ensure access to default color
                const defaultStrokeWidth = 0.2;   // Define or ensure access to default width

                svgContent.selectAll('.heatmap-cell') // Select all heatmap cells within the dendro SVG
                    .transition().duration(150) // Use a short transition for smoothness
                    .style("stroke", defaultStrokeColor) // Set stroke color to default
                    .style("stroke-width", defaultStrokeWidth); // Set stroke width to default

                console.log("Reset tree node highlights AND tree-attached heatmap cell outlines.");
            }
        } catch (error) {
            console.error("Error resetting tree elements:", error);
        }

        // Reset Sidebar Layout Dropdown
        document.getElementById('sidebarLayoutSelect').value = 'cose';
        console.log("Sidebar visualization, color map, selections, table, and related highlights cleared.");
    }

    // Helper function to reset main heatmap highlights
    function resetHeatmapHighlights() {
        console.log("Resetting main heatmap cell highlights.");
        d3.selectAll('#heatmap rect.cell').each(function() { // Target only main heatmap cells
            const cell = d3.select(this);
            const originalColor = cell.attr("data-original-fill"); // Read stored original color
            if (originalColor) { cell.attr("fill", originalColor); }
            else { cell.style("fill", null); }
        });
    }

    // Helper function to reset main heatmap highlights (called by clearSidebarVisualization)
    function resetHeatmapHighlights() {
        console.log("Resetting main heatmap cell highlights.");
        d3.selectAll('#heatmap rect.cell').each(function() { // Target only main heatmap cells
            const cell = d3.select(this);
            const originalColor = cell.attr("data-original-fill"); // Read stored original color
            if (originalColor) {
                // Use transition only if desired, direct attr is faster
                // cell.transition().duration(100)
                cell.attr("fill", originalColor);
            } else {
                // Fallback if original color wasn't stored somehow
                cell.style("fill", null); // Let CSS/default handle it
                console.warn(`Missing original fill for heatmap cell: cluster ${cell.attr('data-cluster')}, metric ${cell.attr('data-metric')}`);
            }
        });
    }

    function calculateEdgeWidth(processCount) {
        const count = processCount || 1;
        const minCount = 1;
        const maxCount = 100;
        const minWidth = 1;
        const maxWidth = 5;
        const range = (maxCount - minCount) || 1;
        const width = minWidth + (maxWidth - minWidth) * ((count - minCount) / range);
        return Math.max(minWidth, Math.min(width, maxWidth));
    }

    const CYTOSCAPE_STYLE = [
        { selector: 'node', style: {
            'background-color': '#888',
            'label': 'data(label)',
            'width': 'mapData(NodeWeight, 0, 1, 15, 60)',
            'height': 'mapData(NodeWeight, 0, 1, 15, 60)',
            'font-size': 10, 'color': '#000',
            'text-valign': 'bottom', 'text-halign': 'center', 'text-margin-y': 4,
            'border-width': 0.5,
            'border-color': '#555',
            'shape': 'ellipse',
            'transition-property': 'background-color, shape, border-color, border-width',
            'transition-duration': '0.15s'
        }},
        { selector: 'edge', style: {
            'line-color': DEFAULT_UNKNOWN_COLOR,
            'target-arrow-color': DEFAULT_UNKNOWN_COLOR,
            'target-arrow-shape': 'triangle', 'curve-style': 'bezier',
            'transition-property': 'line-color, target-arrow-color, width, z-index',
            'transition-duration': '0.15s',
            'z-index': 1
        }},
        { selector: 'node[Classification = "Internal"]', style: {
            'shape': 'square'
        }},
        { selector: 'node[Classification = "External"]', style: {
            'shape': 'ellipse'
        }},
        {
            selector: 'node[?is_attacker]',
            style: {
                'border-color': '#FF3333',
                'border-width': 3,
                'border-style': 'solid'
            }
        }
    ];

    function generateUniqueHighlightColor() {
        const MIN_HUE_DIFF = 30;
        let attempts = 0;
        const existingHues = Array.from(clusterHighlightColors.values()).map(hslString => {
            const match = hslString.match(/hsl\((\d+),/);
            return match ? parseInt(match[1], 10) : -1;
        }).filter(h => h !== -1);

        while (attempts < 100) {
            let hue = Math.floor(Math.random() * 360);
            if ((hue >= 0 && hue <= 25) || (hue >= 335 && hue <= 360) || (hue >= 195 && hue <= 265)) {
                attempts++;
                continue;
            }
            let isDistinct = existingHues.every(existingHue => {
                let diff = Math.abs(hue - existingHue);
                return diff >= MIN_HUE_DIFF && (360 - diff) >= MIN_HUE_DIFF;
            });
            if (isDistinct) {
                const newColor = `hsl(${hue}, 85%, 60%)`;
                console.log(`Generated distinct color: ${newColor} (Hue: ${hue})`);
                return newColor;
            }
            attempts++;
        }
        console.warn("Could not find highly distinct color, using fallback random hue.");
        let fallbackHue;
        do {
            fallbackHue = Math.floor(Math.random() * 360);
        } while ((fallbackHue >= 0 && fallbackHue <= 25) || (fallbackHue >= 335 && fallbackHue <= 360) || (fallbackHue >= 195 && fallbackHue <= 265));
        return `hsl(${fallbackHue}, 85%, 60%)`;
    }

    function deselectCurrentNode() {
        if (selectedNodeId && sidebarCy) {
            const node = sidebarCy.getElementById(selectedNodeId);
            if (node && node.length > 0) {
                const originalColor = node.scratch('_originalColor');
                if (originalColor) {
                    node.style('background-color', originalColor);
                } else {
                    const clusterID = node.data('clusterID');
                    const clusterColor = clusterHighlightColors.get(clusterID) || '#888';
                    node.style('background-color', clusterColor);
                    console.warn(`Missing scratch color for node ${selectedNodeId}, reverted using cluster/default color.`);
                }
                node.connectedEdges().forEach(edge => {
                    const edgeKey = `${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`;
                    if (!selectedSidebarEdges.has(edgeKey)) {
                         const originalEdgeColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                         const originalEdgeWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                         edge.style({
                            'line-color': originalEdgeColor,
                            'target-arrow-color': originalEdgeColor,
                            'width': originalEdgeWidth,
                            'z-index': 1
                         });
                    }
                });
                 node.unselect();
                console.log(`Node ${selectedNodeId} and its non-selected edges deselected.`);
            } else {
                console.warn(`Attempted to deselect node ${selectedNodeId}, but it was not found.`);
            }
            selectedNodeId = null;
        }
    }

    function visualizeClusterInSidebar(clusterID, nodeColor, isAnomalous) {
        return new Promise((resolve, reject) => {
            const stringClusterID = String(clusterID);

            if (sidebarCy && sidebarCy.nodes(`[clusterID = "${stringClusterID}"]`).length > 0 && addedSidebarClusters.has(stringClusterID)) {
                console.log(`Cluster ${stringClusterID} elements already in sidebar. Re-focusing/styling.`);
                sidebarCy.nodes(`[clusterID = "${stringClusterID}"]`).forEach(node => {
                    node.style('background-color', nodeColor);
                    if (!node.scratch('_originalColor')) {
                        node.scratch('_originalColor', nodeColor);
                    }
                });
                if (selectedSidebarNodes.size === 0 && selectedSidebarEdges.size === 0) {
                    loadSidebarClusterTable(stringClusterID, 1);
                } else {
                    console.log("Selections exist, table update will be handled by selection logic if necessary.");
                }
                resolve({ clusterId: stringClusterID, status: 're-focused' });
                return;
            }

            toggleSidebar(true);
            showSidebarLoading(true, false);
            sidebarInfoDiv.innerHTML = `Loading network for Cluster ${stringClusterID}...`;
            sidebarInfoDiv.style.display = 'block';

            fetch(`${API_BASE_URL}/cluster_network?cluster_id=${stringClusterID}`)
                .then(response => {
                    if (!response.ok) throw new Error(`Network error (${response.status}) for Cluster ${stringClusterID}`);
                    return response.json();
                })
                .then(data => {
                    showSidebarLoading(false, false);

                    if (!data || (!data.nodes || data.nodes.length === 0)) {
                        console.log(`No network data to display for Cluster ${stringClusterID}.`);
                        sidebarInfoDiv.innerHTML = `Cluster ${stringClusterID}: No network data.`;
                        sidebarInfoDiv.style.display = 'block';
                        addedSidebarClusters.add(stringClusterID);
                        if (selectedSidebarNodes.size === 0 && selectedSidebarEdges.size === 0) {
                            loadSidebarClusterTable(stringClusterID, 1);
                        }
                        resolve({ clusterId: stringClusterID, status: 'no-data' });
                        return;
                    }

                    const nodesToAdd = data.nodes.map(node => ({
                        group: 'nodes',
                        data: { ...node.data, clusterID: stringClusterID, Classification: node.data.Classification || 'Unknown' },
                        style: {
                            'background-color': nodeColor
                        },
                        scratch: { _originalColor: nodeColor }
                    }));

                    const edgesToAdd = data.edges.map(edge => {
                        const protocol = edge.data.Protocol || 'Unknown';
                        if (!protocolColorMap[protocol]) {
                            let randomColor;
                            do {
                                randomColor = '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
                            } while (randomColor.toLowerCase() === SELECTED_EDGE_COLOR.toLowerCase());
                            protocolColorMap[protocol] = randomColor;
                        }
                        const edgeColor = protocolColorMap[protocol] || DEFAULT_UNKNOWN_COLOR;
                        return {
                            group: 'edges',
                            data: { ...edge.data, clusterID: stringClusterID },
                            style: { 'line-color': edgeColor, 'target-arrow-color': edgeColor },
                            scratch: { _protocolColor: edgeColor }
                        };
                    });

                    if (!sidebarCy) {
                        sidebarCy = cytoscape({
                            container: document.getElementById('sidebar-cy'),
                            elements: { nodes: nodesToAdd, edges: edgesToAdd },
                            style: CYTOSCAPE_STYLE
                        });
                        bindSidebarGraphEvents();
                    } else {
                        sidebarCy.add(nodesToAdd.concat(edgesToAdd));
                    }

                    addedSidebarClusters.add(stringClusterID);
                    sidebarInfoDiv.style.display = 'none';

                    applySidebarSizeControls();
                    let currentLayout = document.getElementById('sidebarLayoutSelect').value;
                    if (sidebarCy.nodes(`[clusterID = "${stringClusterID}"]`).length > 0) {
                        sidebarCy.layout(sidebarLayoutOptions[currentLayout]).run();
                    }
                    
                    updateLegend(sidebarCy.edges());

                    if (selectedSidebarNodes.size === 0 && selectedSidebarEdges.size === 0) {
                        loadSidebarClusterTable(stringClusterID, 1);
                    }
                    resolve({ clusterId: stringClusterID, status: 'loaded' });
                })
                .catch(error => {
                    console.error(`Error visualizing cluster ${stringClusterID} in sidebar:`, error);
                    showSidebarLoading(false, false);
                    sidebarInfoDiv.innerHTML = `Error loading graph for Cluster ${stringClusterID}.`;
                    sidebarInfoDiv.style.display = 'block';
                    addedSidebarClusters.add(stringClusterID);
                    if (selectedSidebarNodes.size === 0 && selectedSidebarEdges.size === 0) {
                       loadSidebarClusterTable(stringClusterID, 1);
                    }
                    reject(error);
                });
        });
    }

    function updateSidebarTableForSelectedNodesAndEdges() {
        showSidebarLoading(false, true);
        sidebarTableContainer.style.display = 'none';
        sidebarTablePagination.style.display = 'none';
        sidebarSearchContainer.style.display = 'none';

        const nodesToFilterBy = Array.from(selectedSidebarNodes);
        const edgesToFilterBy = Array.from(selectedSidebarEdges).map(key => {
            const parts = key.split('|');
            return { source: parts[0], destination: parts[1], protocol: parts[2] };
        });

        if (nodesToFilterBy.length > 0) {
            console.log(`Nodes selected: ${nodesToFilterBy.join(', ')}. Loading table for their connected edges.`);
            let allConnectedEdgesData = new Set();
            let representativeEdgesForTable = [];

            nodesToFilterBy.forEach(nodeId => {
                const node = sidebarCy.getElementById(nodeId);
                if (node.length > 0) {
                    node.connectedEdges().forEach(edge => {
                        const edgeKey = `${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`;
                        if (!allConnectedEdgesData.has(edgeKey)) {
                            allConnectedEdgesData.add(edgeKey);
                            representativeEdgesForTable.push({
                                source: edge.data('source'),
                                destination: edge.data('target'),
                                protocol: edge.data('Protocol')
                            });
                        }
                    });
                }
            });
            if (representativeEdgesForTable.length > 0) {
                loadSidebarMultiEdgeTable(representativeEdgesForTable, 1);
            } else {
                sidebarTableContainer.innerHTML = '<p style="padding:10px; text-align:center; color:#6c757d;">Selected node(s) have no connections.</p>';
                sidebarTableContainer.style.display = 'block';
                showSidebarLoading(false, false);
            }
            sidebarInfoDiv.style.display = 'none';

        } else if (edgesToFilterBy.length > 0) {
            console.log(`Edges selected, loading multi-edge table for ${edgesToFilterBy.length} edges.`);
            loadSidebarMultiEdgeTable(edgesToFilterBy, 1);
            sidebarInfoDiv.style.display = 'none';
        } else {
            console.log("No specific nodes or edges selected. Showing table for current cluster context.");
            if (currentSidebarTableClusterId) {
                loadSidebarClusterTable(currentSidebarTableClusterId, 1);
            } else if (addedSidebarClusters.size > 0) {
                const firstClusterId = addedSidebarClusters.values().next().value;
                if (firstClusterId) loadSidebarClusterTable(firstClusterId, 1);
            } else {
                sidebarTableContainer.innerHTML = '<p id="sidebar-table-no-results" style="display: none; text-align: center; padding: 10px; color: #6c757d;">No rows match your search criteria.</p>';
                sidebarTableContainer.style.display = 'block';
                showSidebarLoading(false, false);
                sidebarInfoDiv.style.display = (!sidebarCy || sidebarCy.elements().length === 0) ? 'block' : 'none';
            }
        }
    }

    function bindSidebarGraphEvents() {
        if (!sidebarCy) return;

        sidebarCy.removeListener('mouseover');
        sidebarCy.removeListener('mouseout');
        sidebarCy.removeListener('click');
        sidebarCy.removeListener('tap');

        sidebarCy.on('mouseover', 'node', (event) => {
            const node = event.target;
            const nodeData = node.data();
            let packetsIn = 0;
            let packetsOut = 0;

            node.connectedEdges().forEach(edge => {
                const edgeData = edge.data();
                const count = edgeData.processCount || 0;
                if (edgeData.target === nodeData.id) {
                    packetsIn += count;
                }
                if (edgeData.source === nodeData.id) {
                    packetsOut += count;
                }
            });

            let tooltipHTML = `Node: ${nodeData.label || nodeData.id}<br>` +
                        `Class: ${nodeData.Classification || 'N/A'}<br>` +
                        `Cluster: ${nodeData.clusterID}<br>`;

            if (nodeData.is_attacker) {
                tooltipHTML += `<strong style="color:#FF3333;">Role: Attacker</strong><br>`;
            }

            tooltipHTML += `Packets In: ${packetsIn}<br>` +
                           `Packets Out: ${packetsOut}`;

            if (nodeData.InvolvedAttackTypes && nodeData.InvolvedAttackTypes.length > 0) {
                tooltipHTML += `<br><strong style="color:crimson;">Node Involved in Attacks: ${nodeData.InvolvedAttackTypes.join(', ')}</strong>`;
            }
            
            tooltip.style("display", "block")
                .html(tooltipHTML);
            
            if (event.originalEvent && typeof event.originalEvent.pageX === 'number' && typeof event.originalEvent.pageY === 'number') {
                tooltip.style("left", (event.originalEvent.pageX + 10) + "px")
                       .style("top", (event.originalEvent.pageY + 10) + "px");
            } else if (event.renderedPosition) {
                const sidebarCyContainer = document.getElementById('sidebar-cy');
                const containerRect = sidebarCyContainer.getBoundingClientRect();
                tooltip.style("left", (containerRect.left + event.renderedPosition.x + 10) + "px")
                       .style("top", (containerRect.top + event.renderedPosition.y + 10) + "px");
            } else {
                console.warn("Tooltip on node: Could not determine position.");
            }
        });

        sidebarCy.on('mouseover', 'edge', (event) => {
            const edge = event.target;
            const edgeData = edge.data();

            let edgeTooltipHTML = `Src: ${edgeData.source}<br>` +
                                `Dst: ${edgeData.target}<br>` +
                                `Proto: ${edgeData.Protocol}<br>` +
                                `Count: ${edgeData.processCount || 0}<br>` +
                                `Cluster: ${edgeData.clusterID}`;

            if (edgeData.AttackType && edgeData.AttackType !== "N/A") {
                edgeTooltipHTML += `<br><strong style="color:crimson;">Edge Attack: ${edgeData.AttackType}</strong>`;
            }

            tooltip.style("display", "block")
                .html(edgeTooltipHTML);

            if (event.originalEvent && typeof event.originalEvent.pageX === 'number' && typeof event.originalEvent.pageY === 'number') {
                tooltip.style("left", (event.originalEvent.pageX + 10) + "px")
                       .style("top", (event.originalEvent.pageY + 10) + "px");
            } else if (event.renderedPosition) {
                const sidebarCyContainer = document.getElementById('sidebar-cy');
                const containerRect = sidebarCyContainer.getBoundingClientRect();
                tooltip.style("left", (containerRect.left + event.renderedPosition.x + 10) + "px")
                       .style("top", (containerRect.top + event.renderedPosition.y - 15) + "px");
            } else {
                console.warn("Tooltip on edge: Could not determine position.");
            }
        });

        sidebarCy.on('mouseout', 'node, edge', () => {
            tooltip.style("display", "none");
        });

        sidebarCy.on('click', 'node', (event) => {
            const clickedNode = event.target;
            const clickedNodeId = clickedNode.id();
            const clusterID = clickedNode.data('clusterID');

            if (event.originalEvent.shiftKey && clusterID) {
                console.log(`Shift+click on node ${clickedNodeId}. Selecting cluster ${clusterID}.`);
                const cellInDendro = d3.select(`#inlineDendrogramSvg .heatmap-cell[data-cluster_id="${clusterID}"]`);
                if (!cellInDendro.empty()) {
                    clusterHighlightColors.delete(String(clusterID));
                    cellInDendro.dispatch('click'); 
                    highlightTreeClusters(new Set(clusterHighlightColors.keys()));
                } else {
                    console.warn(`Could not find heatmap cell for cluster ${clusterID} to simulate selection.`);
                    if (!clusterHighlightColors.has(String(clusterID))) {
                        const highlightColor = generateUniqueHighlightColor();
                        clusterHighlightColors.set(String(clusterID), highlightColor);
                        visualizeClusterInSidebar(clusterID, highlightColor, clickedNode.data('is_attacker')); // Pass node's attacker status
                        highlightTreeClusters(new Set(clusterHighlightColors.keys()));
                    } else {
                        visualizeClusterInSidebar(clusterID, clusterHighlightColors.get(String(clusterID)), clickedNode.data('is_attacker'));
                    }
                }
                loadSidebarClusterTable(clusterID, 1);
                return; 
            }

            if (selectedSidebarEdges.size > 0) {
                selectedSidebarEdges.forEach(edgeKey => {
                    const parts = edgeKey.split('|');
                    const edgeSelector = `edge[source = "${parts[0]}"][target = "${parts[1]}"][Protocol = "${parts[2]}"]`;
                    const edge = sidebarCy.elements(edgeSelector);
                    if (edge.length > 0) {
                        const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                        const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                        edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
                        edge.unselect();
                    }
                });
                selectedSidebarEdges.clear();
            }

            if (selectedSidebarNodes.has(clickedNodeId)) {
                selectedSidebarNodes.delete(clickedNodeId);
                const originalNodeColor = clickedNode.scratch('_originalColor') || clusterHighlightColors.get(clickedNode.data('clusterID')) || '#888';
                clickedNode.style('background-color', originalNodeColor);
                clickedNode.unselect();
                console.log(`Node ${clickedNodeId} deselected.`);

                clickedNode.connectedEdges().forEach(edge => {
                    const sourceId = edge.source().id();
                    const targetId = edge.target().id();
                    let otherNodeIsSelected = false;

                    if (sourceId === clickedNodeId && selectedSidebarNodes.has(targetId)) {
                        otherNodeIsSelected = true;
                    } else if (targetId === clickedNodeId && selectedSidebarNodes.has(sourceId)) {
                        otherNodeIsSelected = true;
                    }

                    if (otherNodeIsSelected) {
                        const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                        edge.style({
                            'line-color': SELECTED_EDGE_COLOR,
                            'target-arrow-color': SELECTED_EDGE_COLOR,
                            'width': originalWidth,
                            'z-index': SELECTED_EDGE_ZINDEX
                        });
                    } else {
                        const edgeKey = `${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`;
                        if (!selectedSidebarEdges.has(edgeKey)) {
                            const originalEdgeColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                            const originalEdgeWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                            edge.style({
                                'line-color': originalEdgeColor,
                                'target-arrow-color': originalEdgeColor,
                                'width': originalEdgeWidth,
                                'z-index': 1
                            });
                        }
                    }
                });

            } else {
                selectedSidebarNodes.add(clickedNodeId);
                if (!clickedNode.scratch('_originalColor')) {
                    clickedNode.scratch('_originalColor', clickedNode.style('background-color'));
                }
                clickedNode.style('background-color', SELECTED_NODE_COLOR);
                clickedNode.select();
                console.log(`Node ${clickedNodeId} selected.`);

                clickedNode.connectedEdges().forEach(edge => {
                    if (!edge.scratch('_originalWidth')) {
                        edge.scratch('_originalWidth', edge.style('width'));
                    }
                    if (!edge.scratch('_protocolColor')) {
                        edge.scratch('_protocolColor', edge.style('line-color'));
                    }
                    const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                    edge.style({
                        'line-color': SELECTED_EDGE_COLOR,
                        'target-arrow-color': SELECTED_EDGE_COLOR,
                        'width': originalWidth,
                        'z-index': SELECTED_EDGE_ZINDEX
                    });
                });
            }
            updateSidebarTableForSelectedNodesAndEdges();
            sidebarInfoDiv.style.display = 'none';
        });

        sidebarCy.on('click', 'edge', (event) => {
            const edge = event.target;
            const source = edge.data('source');
            const target = edge.data('target');
            const protocol = edge.data('Protocol');
            const edgeKey = `${source}|${target}|${protocol}`;
            const clusterID = edge.data('clusterID'); 

            if (event.originalEvent.shiftKey && clusterID) {
                console.log(`Shift+click on edge ${edgeKey}. Selecting cluster ${clusterID}.`);
                const cellInDendro = d3.select(`#inlineDendrogramSvg .heatmap-cell[data-cluster_id="${clusterID}"]`);
                if (!cellInDendro.empty()) {
                    clusterHighlightColors.delete(String(clusterID));
                    cellInDendro.dispatch('click');
                    highlightTreeClusters(new Set(clusterHighlightColors.keys()));
                } else {
                    console.warn(`Could not find heatmap cell for cluster ${clusterID} to simulate selection.`);
                    if (!clusterHighlightColors.has(String(clusterID))) {
                        const highlightColor = generateUniqueHighlightColor();
                        clusterHighlightColors.set(String(clusterID), highlightColor);
                        visualizeClusterInSidebar(clusterID, highlightColor, false);
                        highlightTreeClusters(new Set(clusterHighlightColors.keys()));
                    } else {
                        visualizeClusterInSidebar(clusterID, clusterHighlightColors.get(String(clusterID)), false);
                    }
                }
                loadSidebarClusterTable(clusterID, 1);
                return; 
            }

            if (selectedSidebarNodes.size > 0) {
                selectedSidebarNodes.forEach(nodeId => {
                    const node = sidebarCy.getElementById(nodeId);
                    if (node.length > 0) {
                        const originalNodeColor = node.scratch('_originalColor') || clusterHighlightColors.get(node.data('clusterID')) || '#888';
                        node.style('background-color', originalNodeColor);
                        node.unselect();
                        node.connectedEdges().forEach(connEdge => {
                            const connEdgeKey = `${connEdge.data('source')}|${connEdge.data('target')}|${connEdge.data('Protocol')}`;
                            if (!selectedSidebarEdges.has(connEdgeKey) && connEdgeKey !== edgeKey) {
                                const originalEdgeColor = connEdge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                                const originalEdgeWidth = connEdge.scratch('_originalWidth') || calculateEdgeWidth(connEdge.data('processCount'));
                                connEdge.style({
                                    'line-color': originalEdgeColor,
                                    'target-arrow-color': originalEdgeColor,
                                    'width': originalEdgeWidth,
                                    'z-index': 1
                                });
                            }
                        });
                    }
                });
                selectedSidebarNodes.clear();
            }

            if (selectedSidebarEdges.has(edgeKey)) {
                selectedSidebarEdges.delete(edgeKey);
                const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
                edge.unselect();
            } else {
                selectedSidebarEdges.add(edgeKey);
                const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                edge.style({
                    'line-color': SELECTED_EDGE_COLOR,
                    'target-arrow-color': SELECTED_EDGE_COLOR,
                    'width': originalWidth, 
                    'z-index': SELECTED_EDGE_ZINDEX
                });
                edge.select();
            }
            updateSidebarTableForSelectedNodesAndEdges();
        });

        sidebarCy.on('tap', function(event){
            if (event.target === sidebarCy) {
                let deselectedSomething = false;

                if (selectedSidebarNodes.size > 0) {
                    selectedSidebarNodes.forEach(nodeId => {
                        const node = sidebarCy.getElementById(nodeId);
                        if (node.length > 0) {
                            const originalColor = node.scratch('_originalColor') || clusterHighlightColors.get(node.data('clusterID')) || '#888';
                            node.style('background-color', originalColor);
                            node.unselect();
                            node.connectedEdges().forEach(edge => {
                                const edgeKey = `${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`;
                                if (!selectedSidebarEdges.has(edgeKey)) {
                                    const originalEdgeColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                                    const originalEdgeWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                                    edge.style({
                                        'line-color': originalEdgeColor,
                                        'target-arrow-color': originalEdgeColor,
                                        'width': originalEdgeWidth,
                                        'z-index': 1
                                    });
                                }
                            });
                        }
                    });
                    selectedSidebarNodes.clear();
                    deselectedSomething = true;
                    console.log("Node selections cleared by tapping sidebar background.");
                }

                if (selectedSidebarEdges.size > 0) {
                    selectedSidebarEdges.forEach(edgeKey => {
                        const parts = edgeKey.split('|');
                        const edgeSelector = `edge[source = "${parts[0]}"][target = "${parts[1]}"][Protocol = "${parts[2]}"]`;
                        const edge = sidebarCy.elements(edgeSelector);
                        if (edge.length > 0) {
                            const originalColor = edge.scratch('_protocolColor') || DEFAULT_UNKNOWN_COLOR;
                            const originalWidth = edge.scratch('_originalWidth') || calculateEdgeWidth(edge.data('processCount'));
                            edge.style({ 'line-color': originalColor, 'target-arrow-color': originalColor, 'width': originalWidth, 'z-index': 1 });
                            edge.unselect();
                        }
                    });
                    selectedSidebarEdges.clear();
                    deselectedSomething = true;
                    console.log("Edge selections cleared by tapping sidebar background.");
                }

                if (deselectedSomething) {
                    updateSidebarTableForSelectedNodesAndEdges();
                }
                sidebarInfoDiv.style.display = (!sidebarCy || sidebarCy.elements().length === 0) ? 'block' : 'none';
            }
        });
    }

    function applySidebarSizeControls() {
        if (!sidebarCy || sidebarCy.elements().length === 0) {
            console.log("Sidebar graph not ready or empty, skipping size update.");
            return;
        }

        // Read min/max inputs according to new requirements
        const minNS_input = parseFloat(document.getElementById('sidebarNodeSizeMin').value) || 2;
        const maxNS_input_val = document.getElementById('sidebarNodeSizeMax').value;
        const maxNS_input = maxNS_input_val ? parseFloat(maxNS_input_val) : Infinity;

        // Edge width logic remains the same.
        const minEW_input = Math.max(parseFloat(document.getElementById('sidebarEdgeWidthMin').value) || 1, 0.1);
        const maxEW_input = Math.max(parseFloat(document.getElementById('sidebarEdgeWidthMax').value) || 8, minEW_input + 0.1);

        sidebarCy.batch(() => {
            const nodes = sidebarCy.nodes();
            if (nodes.length > 0) {
                const allDiameters = []; // Array to store calculated diameters

                nodes.forEach(n => {
                    const packetCount = n.data('packetCount') || 0;
                    // 1. Calculate size based on square root of packet count.
                    let diameter = Math.sqrt(packetCount);

                    // 2. Apply minimum size constraint.
                    diameter = Math.max(minNS_input, diameter);

                    // 3. Apply maximum size constraint ONLY if user provided a finite number.
                    if (isFinite(maxNS_input)) {
                        diameter = Math.min(diameter, maxNS_input);
                    }
                    
                    allDiameters.push(diameter); // Store the final diameter for this node

                    const styleToApply = {
                        'width': diameter,
                        'height': diameter
                    };

                    // Check if the node is an attacker and set proportional border width
                    if (n.data('is_attacker')) {
                        const borderWidth = Math.max(2, Math.min(diameter * 0.1, 10));
                        styleToApply['border-width'] = borderWidth;
                    }

                    // Avoid overriding styles of actively selected nodes
                    if (!selectedSidebarNodes.has(n.id())) {
                        n.style(styleToApply);
                    }
                });
                
                // --- NEW: Update the placeholder for the max node size input ---
                if (allDiameters.length > 0) {
                    const currentMaxNodeSize = Math.max(...allDiameters);
                    const maxNodeSizeInput = document.getElementById('sidebarNodeSizeMax');
                    if (maxNodeSizeInput) {
                        // Update the placeholder with the calculated max, formatted to 2 decimal places.
                        maxNodeSizeInput.placeholder = currentMaxNodeSize.toFixed(2);
                    }
                }
            }

            // --- Edge Width Logic (Unchanged) ---
            const edges = sidebarCy.edges();
            if (edges.length > 0) {
                const edgeCounts = edges.map(e => e.data('processCount') || 1);
                const actualMinCount = Math.max(1, Math.min(...edgeCounts));
                const actualMaxCount = Math.max(actualMinCount, Math.max(...edgeCounts));
                const countRange = (actualMaxCount - actualMinCount);

                edges.forEach(e => {
                    const count = e.data('processCount') || 1;
                    let normalizedCount = 0;
                    if (countRange > 0) {
                        const clampedCount = Math.max(actualMinCount, Math.min(count, actualMaxCount));
                        normalizedCount = (clampedCount - actualMinCount) / countRange;
                    } else if (edges.length > 0) {
                        normalizedCount = 0;
                    }
                    let width = minEW_input + normalizedCount * (maxEW_input - minEW_input);
                    width = Math.max(minEW_input, Math.min(width, maxEW_input));

                    e.scratch('_originalWidth', width);
                    
                    const edgeKey = `${e.data('source')}|${e.data('target')}|${e.data('Protocol')}`;
                    const edgeIsSelected = selectedSidebarEdges.has(edgeKey);

                    if (!edgeIsSelected) {
                        e.style('width', width);
                    } else {
                        e.style('width', SELECTED_EDGE_WIDTH);
                    }
                });
            }
        }); 
    }

    function updateSidebarTableForSelectedEdges() {
        // --- Handle Node Selection First ---
        if (selectedNodeId && sidebarCy) {
            const node = sidebarCy.getElementById(selectedNodeId);
            if (node && node.length > 0) {
                const connectedEdgeData = node.connectedEdges().map(edge => ({
                    source: edge.data('source'),
                    destination: edge.data('target'),
                    protocol: edge.data('Protocol')
                }));
                 if (connectedEdgeData.length > 0) {
                    console.log(`Node ${selectedNodeId} selected, loading its multi-edge table.`);
                    loadSidebarMultiEdgeTable(connectedEdgeData, 1);
                 } else {
                    console.log(`Node ${selectedNodeId} selected, but has no connections.`);
                    sidebarTableContainer.innerHTML = '<p id="sidebar-table-no-results" style="display: none; text-align: center; padding: 10px; color: #6c757d;">No rows match your search criteria.</p><p style="padding:10px; text-align:center; color:#6c757d;">Selected node has no connections.</p>';
                    sidebarTableContainer.style.display = 'block';
                    sidebarTablePagination.style.display = 'none';
                    sidebarSearchContainer.style.display = 'none'; // Hide search for empty table
                 }
                 sidebarInfoDiv.style.display = 'none'; // Hide default info
                 return; // Exit function after handling node selection
            } else {
                 // Node ID was selected but node not found (maybe removed), reset selection
                 console.warn(`Selected node ${selectedNodeId} not found, resetting selection state.`);
                 selectedNodeId = null; // Resetting here, deselectCurrentNode might have been called already
            }
        }

        if (selectedSidebarEdges.size > 0) {
            const edgeList = Array.from(selectedSidebarEdges).map(key => {
                const parts = key.split('|');
                return { source: parts[0], destination: parts[1], protocol: parts[2] };
            });
            console.log(`Edges selected, loading multi-edge table for ${edgeList.length} edges.`);
            loadSidebarMultiEdgeTable(edgeList, 1);
            sidebarInfoDiv.style.display = 'none'; // Hide default info
        }
        else {
            console.log("No node or edge selected. Checking for remaining added clusters...");
            if (addedSidebarClusters.size > 0) {
                // If clusters remain in the sidebar, show table for the first one
                const firstRemainingClusterId = addedSidebarClusters.values().next().value;
                console.log(`Loading table for first remaining cluster: ${firstRemainingClusterId}`);
                loadSidebarClusterTable(firstRemainingClusterId, 1);
                sidebarInfoDiv.style.display = 'none'; // Hide default info if showing cluster table
            } else {
                // If no clusters remain, clear table and show default info message
                console.log("No clusters remain in the sidebar. Clearing table and showing info message.");
                sidebarTableContainer.innerHTML = '<p id="sidebar-table-no-results" style="display: none; text-align: center; padding: 10px; color: #6c757d;">No rows match your search criteria.</p>'; // Clear table content
                sidebarTableContainer.style.display = 'none'; // Hide table container
                sidebarTablePagination.style.display = 'none'; // Hide pagination
                sidebarSearchContainer.style.display = 'none'; // Hide search
                sidebarInfoDiv.innerHTML = 'Click a cell on the heatmap to add its cluster. Click nodes or edges in the graph to highlight and filter the table below.'; // Default message
                sidebarInfoDiv.style.display = 'block'; // Show info message
                currentSidebarTableClusterId = null; // Ensure no stale cluster ID remains
                sidebarTableMode = 'cluster'; // Reset mode
            }
        }
    }

    function loadSidebarMultiEdgeTable(edgeList, page, searchQuery = "") {
        if (!edgeList || edgeList.length === 0) {
            updateSidebarTableForSelectedEdges();
            return;
        }
        sidebarTableMode = 'edges';
        showSidebarLoading(false, true);
        sidebarTableContainer.style.display = 'none';
        sidebarSearchContainer.style.display = 'block';

        const payload = {
            edges: edgeList,
            page: page,
            page_size: TABLE_PAGE_SIZE,
            search: searchQuery
        };

        fetch(`${API_BASE_URL}/get_multi_edge_table`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(response => response.ok ? response.json() : Promise.reject(`Failed multi-edge table page (${response.status})`))
        .then(data => {
            showSidebarLoading(false, false);
            _renderSidebarTable(data, page);
            sidebarTableContainer.scrollTop = 0;
        })
        .catch(error => {
            console.error("Error fetching multi-edge sidebar table:", error);
            showSidebarLoading(false, false);
            sidebarTableContainer.innerHTML = `<p style="color: red; padding: 10px;">Error loading table data for selected edges.</p>`;
            sidebarTableContainer.style.display = 'block';
        });
    }

    function applyAllHeatmapHighlights() {
        d3.selectAll('rect.cell').each(function() {
            const cell = d3.select(this);
            const originalColor = cell.attr("data-original-fill");
            if (originalColor) { cell.attr("fill", originalColor); }
        });
        clusterHighlightColors.forEach((color, clusterId) => {
            d3.selectAll('rect.cell[data-cluster="' + clusterId + '"]').attr('fill', color);
        });
    }

    function showLoading() {
        globalAbortController = new AbortController();
        document.getElementById('loading-overlay').style.display = 'flex';
        const cancelBtn = document.getElementById('cancelLoadingBtn');
        if (cancelBtn) {
            cancelBtn.disabled = false;
        }
    }
    function hideLoading() { document.getElementById('loading-overlay').style.display = 'none'; }

    function updateLegend(cyEdges = null) {
        const legendTitleElement = document.getElementById('protocol-legend-title'); // Get the specific title element
        const legendTableBody = d3.select('#legend tbody');

        let protocols = new Set();
        let calculationPromise;
        let totalCount = 0;

        if (cyEdges && cyEdges.length > 0) {
            // Sidebar Mode: Calculate percentages locally
            if (legendTitleElement) legendTitleElement.textContent = "Sidebar Protocols";
            const counts = {};
            cyEdges.forEach(edge => {
                const protocol = (edge.data('Protocol') || 'Unknown').trim();
                if (!protocol) return;
                protocols.add(protocol);
                const count = edge.data('processCount') || 1;
                counts[protocol] = (counts[protocol] || 0) + count;
                totalCount += count;
            });
            totalCount = totalCount || 1; // Avoid division by zero
            const percentages = {};
            Object.entries(counts).forEach(([p, c]) => { percentages[p] = (c / totalCount) * 100; });
            calculationPromise = Promise.resolve(percentages); // Resolve immediately
        } else {
            // Global Mode: Fetch percentages from backend
            if (legendTitleElement) legendTitleElement.textContent = "Protocol Legend"; // Default title
            calculationPromise = fetch(`${API_BASE_URL}/protocol_percentages`)
                .then(res => {
                    if (!res.ok) { // Check if response is not OK
                        // Try to parse JSON error, otherwise use status text
                        return res.json().catch(() => ({ error: `Failed global percentages. Status: ${res.status}` })).then(err => {
                            // If it's an object with an error key, use that, otherwise create one.
                            throw new Error(err.error || `Failed global percentages. Status: ${res.statusText || res.status}`);
                        });
                    }
                    return res.json();
                })
                .catch(error => {
                    console.error("Error fetching global protocol percentages:", error.message || error);
                    // Ensure legend title is set even on error
                    if (legendTitleElement) legendTitleElement.textContent = "Protocol Legend (Error)";
                    return {}; // Return empty object on error to prevent further issues
                });
        }

        // Common logic after getting percentages
        calculationPromise.then(percentages => {
            legendTableBody.html(''); // Clear the table *just before* adding new rows

            if (!cyEdges || cyEdges.length === 0) { // Only if in global mode and percentages might define protocols
                Object.keys(percentages).forEach(proto => { if(proto) protocols.add(proto); });
            }

            protocols.forEach(proto => {
                if (proto && !protocolColorMap[proto]) {
                    let randomColor;
                    do {
                        randomColor = '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
                    } while (randomColor.toLowerCase() === SELECTED_EDGE_COLOR.toLowerCase());
                    protocolColorMap[proto] = randomColor;
                }
            });
            if (!protocolColorMap['Unknown']) {
                protocolColorMap['Unknown'] = DEFAULT_UNKNOWN_COLOR;
            }

            const sortedProtocols = Array.from(protocols).filter(p => p).sort((a, b) => (percentages[b] || 0) - (percentages[a] || 0));

            sortedProtocols.forEach(protocol => {
                const pct = percentages[protocol] || 0;
                const pctText = (pct > 0.01 ? pct.toFixed(2) : (pct > 0 ? '<0.01' : '0.00')) + '%';
                const color = protocolColorMap[protocol] || DEFAULT_UNKNOWN_COLOR;
                legendTableBody.append('tr').html(
                    `<td>${protocol}</td><td><span class="color-box" style="background-color:${color}"></span></td><td>${pctText}</td>`
                );
            });

            if (sidebarCy) {
                sidebarCy.edges().forEach(edge => {
                    const protocol = edge.data('Protocol') || 'Unknown';
                    const newColor = protocolColorMap[protocol] || DEFAULT_UNKNOWN_COLOR;
                    const edgeKey = `${edge.data('source')}|${edge.data('target')}|${edge.data('Protocol')}`;
                    // Check if any connected node is the currently selected single node
                    const sourceNodeSelected = selectedNodeId && edge.source().id() === selectedNodeId;
                    const targetNodeSelected = selectedNodeId && edge.target().id() === selectedNodeId;
                    const edgeIsSelected = selectedSidebarEdges.has(edgeKey);

                    if (!sourceNodeSelected && !targetNodeSelected && !edgeIsSelected) {
                        edge.style({'line-color': newColor, 'target-arrow-color': newColor});
                    }
                    edge.scratch('_protocolColor', newColor);
                });
            }
        }).catch(error => { // Catch errors from the calculationPromise itself
            console.error("Error processing percentages for legend:", error);
            if (legendTitleElement) legendTitleElement.textContent = "Protocol Legend (Data Error)";
            legendTableBody.html('<tr><td colspan="3" style="text-align:center;color:red;">Could not load protocol data.</td></tr>');
        });
    }

    function updateHeatmap() {
        return new Promise((resolve, reject) => {
            window.fullHeatmapData = {};
            window.heatmapSortOrders = {};
            window.heatmapCountSortOrder = [];

            const filterParamsBase = {
                payloadKeyword: document.getElementById('payloadSearch').value.trim().toLowerCase(),
                sourceFilter: document.getElementById('sourceFilter').value.trim().toLowerCase(),
                destinationFilter: document.getElementById('destinationFilter').value.trim().toLowerCase(),
                protocolFilter: document.getElementById('protocolFilter').value.trim().toLowerCase(),
                minSourceAmt: document.getElementById('minSourceAmtFilter').value,
                maxSourceAmt: document.getElementById('maxSourceAmtFilter').value,
                minDestinationAmt: document.getElementById('minDestinationAmtFilter').value,
                maxDestinationAmt: document.getElementById('maxDestinationAmtFilter').value
            };

            if (window.currentTimeSelection) {
                filterParamsBase.start_time = window.currentTimeSelection.startTime.toISOString();
                filterParamsBase.end_time = window.currentTimeSelection.endTime.toISOString();
            }

            Promise.all(metrics.map(m => {
                const filterParams = { ...filterParamsBase, metric: m.value };
                
                return fetch(`${API_BASE_URL}/filter_and_aggregate`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(filterParams),
                        signal: globalAbortController.signal
                    })
                    .then(response => {
                        if (!response.ok) throw new Error('Network response was not ok');
                        return response.json();
                    })
                    .then(data => ({ metric: m.label, pivotData: data }))
                    .catch(error => {
                        if (error.name === 'AbortError') console.log(`Heatmap fetch aborted for ${m.label}.`);
                        else console.error(`Error fetching heatmap for ${m.label}:`, error);
                        return { metric: m.label, pivotData: [], error: true };
                    });
            }))
            .then(results => {
                const validResults = results.filter(r => !r.error);
                validResults.forEach(r => {
                    window.fullHeatmapData[r.metric] = r.pivotData;
                });
                resolve(validResults);
            })
            .catch(error => reject(error));
        });
    }

    function updateRowOrderSelectState() {
        const dendrogramSortSelect = document.getElementById('dendrogramSortMetricSelect');
        const rowOrderSelect = document.getElementById('rowOrderSelect');
        const rowOrderLabel = document.querySelector('label[for="rowOrderSelect"]');

        if (!dendrogramSortSelect || !rowOrderSelect || !rowOrderLabel) {
            console.warn("Could not find all elements for updating rowOrderSelect state.");
            return;
        }

        if (dendrogramSortSelect.value === 'Default') {
            rowOrderSelect.disabled = true;
            rowOrderSelect.style.opacity = '0.5';
            rowOrderSelect.style.pointerEvents = 'none';
            rowOrderLabel.style.opacity = '0.5';
        } else {
            rowOrderSelect.disabled = false;
            rowOrderSelect.style.opacity = '';
            rowOrderSelect.style.pointerEvents = '';
            rowOrderLabel.style.opacity = '';
        }
    }

    function loadSidebarClusterTable(clusterID, page, searchQuery = "") {
        if (!clusterID) return;
        sidebarTableMode = 'cluster';
        currentSidebarTableClusterId = clusterID;
        showSidebarLoading(false, true);
        sidebarTableContainer.style.display = 'none';
        sidebarSearchContainer.style.display = 'block';

        const searchParam = searchQuery ? `&search=${encodeURIComponent(searchQuery)}` : "";
        const url = `${API_BASE_URL}/get_cluster_table?cluster_id=${clusterID}&page=${page}&page_size=${TABLE_PAGE_SIZE}${searchParam}`;

        fetch(url)
            .then(response => response.ok ? response.json() : Promise.reject(`Failed to fetch cluster table (${response.status})`))
            .then(data => {
                showSidebarLoading(false, false);
                _renderSidebarTable(data, page);
                sidebarTableContainer.scrollTop = 0;
            })
            .catch(error => {
                console.error("Error fetching sidebar cluster table:", error);
                showSidebarLoading(false, false);
                sidebarTableContainer.innerHTML = `<p style="color: red; padding: 10px;">Error loading table data.</p>`;
                sidebarTableContainer.style.display = 'block';
            });
    }

    sidebarGoPageBtn.addEventListener('click', function () {
        let pageInput = document.getElementById('sidebarCurrentPageInput');
        let page = parseInt(pageInput.value, 10);
        const totalPagesStr = document.getElementById('sidebarTotalPages').textContent;
        const totalPages = totalPagesStr === '?' ? Infinity : parseInt(totalPagesStr, 10);
        const searchQuery = document.getElementById('sidebarTableSearchInput').value || "";

        if (!isNaN(page) && page >= 1 && (page <= totalPages || totalPages === Infinity)) {
            if (sidebarTableMode === 'cluster' && currentSidebarTableClusterId) {
                loadSidebarClusterTable(currentSidebarTableClusterId, page, searchQuery);
            } else if (sidebarTableMode === 'edges') {
                let edgeList = [];
                if (selectedSidebarNodes.size > 0 && sidebarCy) {
                    selectedSidebarNodes.forEach(nodeId => {
                        const node = sidebarCy.getElementById(nodeId);
                        if (node && node.length > 0) {
                           node.connectedEdges().forEach(edge => {
                                edgeList.push({ source: edge.data('source'), destination: edge.data('target'), protocol: edge.data('Protocol') });
                           });
                        }
                    });
                    edgeList = Array.from(new Set(edgeList.map(JSON.stringify)), JSON.parse);
                } else if (selectedSidebarEdges.size > 0) {
                   edgeList = Array.from(selectedSidebarEdges).map(key => {
                       const parts = key.split('|');
                       return { source: parts[0], destination: parts[1], protocol: parts[2] };
                   });
                }
                if (edgeList.length > 0) {
                    loadSidebarMultiEdgeTable(edgeList, page, searchQuery);
                }
            }
        } else {
            alert(`Please enter a valid page number between 1 and ${totalPagesStr}.`);
        }
    });

    function loadClusterTablePage(clusterID, page) {
        currentClusterID = clusterID;
        fetch(`${API_BASE_URL}/get_cluster_table?cluster_id=${clusterID}&page=${page}&page_size=${TABLE_PAGE_SIZE}`)
            .then(response => response.ok ? response.text() : Promise.reject(`Failed main table page (${response.status})`))
            .then(html => {
                const container = document.getElementById('table-container');
                container.innerHTML = html;
                container.style.display = 'block';
                document.getElementById('table-pagination').style.display = 'block';

                const summaryElem = container.querySelector('#table-summary');
                if (summaryElem && summaryElem.dataset.total) {
                    const total = parseInt(summaryElem.dataset.total, 10);
                    const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
                    document.getElementById('totalPages').textContent = totalPages || 1;
                    document.getElementById('currentPageInput').value = page;
                    document.getElementById('currentPageInput').max = totalPages || 1;
                } else {
                    document.getElementById('totalPages').textContent = '?';
                    document.getElementById('currentPageInput').value = page;
                    console.warn("No table summary total in main table response.");
                }
                container.scrollTop = 0;
            }).catch(error => {
                console.error("Error fetching main cluster table:", error);
                document.getElementById('table-container').innerHTML = `<p style="color: red; padding: 10px;">Error loading table data.</p>`;
                document.getElementById('table-container').style.display = 'block';
                document.getElementById('table-pagination').style.display = 'none';
            });
       }

    function createClusterTable(clusterID) {
        loadClusterTablePage(clusterID, 1);
        document.getElementById('table-search-container').style.display = "block";
       }

    function visualizeNetwork(elements) {
        if (globalCy) { globalCy.destroy(); }
        globalCy = cytoscape({
            container: document.getElementById('cy'),
            elements: elements,
            style: CYTOSCAPE_STYLE,
            layout: { name: 'cose' }
        });
        applySizeControls();
       }

    function applySizeControls() {
        if (!globalCy) return;
        const minNS = Math.max(parseFloat(document.getElementById('nodeSizeMin').value) || 15, 1);
        const maxNS = Math.max(parseFloat(document.getElementById('nodeSizeMax').value) || 60, minNS + 1);
        const minEW = Math.max(parseFloat(document.getElementById('edgeWidthMin').value) || 1, 0.1);
        const maxEW = Math.max(parseFloat(document.getElementById('edgeWidthMax').value) || 10, minEW + 0.1);

        globalCy.batch(() => {
            globalCy.nodes().forEach(n => {
                const weight = n.data('NodeWeight') ?? 0.5;
                let size = minNS + (maxNS - minNS) * weight;
                size = Math.max(minNS, Math.min(size, maxNS));
                n.style({ 'width': size, 'height': size });
            });
            const counts = globalCy.edges().map(e => e.data('processCount') || 1);
            if (counts.length > 0) {
                const minCount = Math.min(...counts);
                const maxCount = Math.max(...counts);
                const countRange = (maxCount - minCount) || 1;

                globalCy.edges().forEach(e => {
                    const count = e.data('processCount') || 1;
                    let width = minEW + (maxEW - minEW) * ((count - minCount) / countRange);
                    width = Math.max(minEW, Math.min(width, maxEW));
                    e.style('width', width);
                });
            }
        });
       }

    function applyEdgeFilter() {
        if (!globalCy) return;
        const sourceFilter = document.getElementById('edgeFilterSource').value.toLowerCase();
        const destFilter = document.getElementById('edgeFilterDestination').value.toLowerCase();
        const protoFilter = document.getElementById('edgeFilterProtocol').value.toLowerCase();
        const weightFilterStr = document.getElementById('edgeFilterWeight').value;
        const countFilterStr = document.getElementById('edgeFilterProcessCount').value;

        const parseFilter = (filterStr) => {
            const match = filterStr.match(/^([<>=!]+)?\s*(\d+(\.\d+)?)$/);
            if (match) {
                const operator = match[1] || '==';
                const value = parseFloat(match[2]);
                return { operator, value };
            }
            return null;
        };
        const weightFilter = parseFilter(weightFilterStr);
        const countFilter = parseFilter(countFilterStr);

        globalCy.edges().forEach(edge => {
            let show = true;
            const data = edge.data();

            if (sourceFilter && !data.source?.toLowerCase().includes(sourceFilter)) show = false;
            if (destFilter && !data.target?.toLowerCase().includes(destFilter)) show = false;
            if (protoFilter && !data.Protocol?.toLowerCase().includes(protoFilter)) show = false;

            if (weightFilter && show) {
                const edgeWeight = data.EdgeWeight || 0;
                switch (weightFilter.operator) {
                    case '>=': if (!(edgeWeight >= weightFilter.value)) show = false; break;
                    case '>':  if (!(edgeWeight > weightFilter.value)) show = false; break;
                    case '<=': if (!(edgeWeight <= weightFilter.value)) show = false; break;
                    case '<':  if (!(edgeWeight < weightFilter.value)) show = false; break;
                    case '==': if (!(edgeWeight == weightFilter.value)) show = false; break;
                    case '!=': if (!(edgeWeight != weightFilter.value)) show = false; break;
                }
            }

            if (countFilter && show) {
                const processCount = data.processCount || 0;
                 switch (countFilter.operator) {
                    case '>=': if (!(processCount >= countFilter.value)) show = false; break;
                    case '>':  if (!(processCount > countFilter.value)) show = false; break;
                    case '<=': if (!(processCount <= countFilter.value)) show = false; break;
                    case '<':  if (!(processCount < countFilter.value)) show = false; break;
                    case '==': if (!(processCount == countFilter.value)) show = false; break;
                    case '!=': if (!(processCount != countFilter.value)) show = false; break;
                }
            }
            edge.style('display', show ? 'element' : 'none');
        });
       }

    function clearEdgeFilter() {
        document.getElementById('edgeFilterSource').value = '';
        document.getElementById('edgeFilterDestination').value = '';
        document.getElementById('edgeFilterProtocol').value = '';
        document.getElementById('edgeFilterWeight').value = '';
        document.getElementById('edgeFilterProcessCount').value = '';
        if(globalCy) { globalCy.edges().style('display', 'element'); }
       }

    function toggleSidebarFullscreen() {
        if (!document.fullscreenEnabled) {
            alert("Fullscreen mode is not supported by your browser.");
            return;
        }

        if (!document.fullscreenElement && !isSidebarFullscreen) {
            // Enter fullscreen
            sidebar.requestFullscreen().then(() => {
                // NEW: Move tooltip inside the sidebar to ensure it's in the same rendering layer
                if (tooltip && sidebar) {
                    sidebar.appendChild(tooltip.node());
                }

                sidebar.classList.add('fullscreen');
                legendContainer.classList.add('fullscreen-active');
                document.body.classList.add('sidebar-fullscreen');
                isSidebarFullscreen = true;
                sidebarFullscreenBtn.innerHTML = '&#x274C;';
                sidebarFullscreenBtn.title = "Exit Sidebar Fullscreen";
                console.log("Entered sidebar fullscreen.");
                if (sidebarCy) {
                    setTimeout(() => {
                        sidebarCy.resize();
                        sidebarCy.fit(null, 50);
                    }, 100);
                }
            }).catch(err => {
                alert(`Error attempting to enable fullscreen mode: ${err.message} (${err.name})`);
                console.error("Fullscreen request failed:", err);
            });
        } else if (document.fullscreenElement === sidebar || isSidebarFullscreen) {
            // Exit fullscreen
            document.exitFullscreen().catch(err => {
                alert(`Error attempting to disable fullscreen mode: ${err.message} (${err.name})`);
                console.error("Fullscreen exit failed:", err);
                // Ensure cleanup is called even on error
                cleanupFullscreenStyles();
            });
        } else {
            console.warn("Fullscreen state mismatch detected.");
            cleanupFullscreenStyles();
        }
    }

    function cleanupFullscreenStyles() {
        // NEW: Move tooltip back to the body so it works in normal mode
        if (tooltip && document.body) {
            document.body.appendChild(tooltip.node());
        }

        sidebar.classList.remove('fullscreen');
        legendContainer.classList.remove('fullscreen-active');
        document.body.classList.remove('sidebar-fullscreen');
        isSidebarFullscreen = false;
        sidebarFullscreenBtn.innerHTML = '&#x2922;';
        sidebarFullscreenBtn.title = "Toggle Sidebar Fullscreen";
        console.log("Cleaned up fullscreen styles.");
        // This call is important to restore the non-fullscreen layout correctly
        toggleSidebar(isSidebarOpen);
    }

    document.addEventListener('DOMContentLoaded', async () => {
        const page_load_render_start_time = performance.now();
        const csvProcessTimeDiv = document.getElementById('csvProcessTime');
        if (csvProcessTimeDiv) {
            csvProcessTimeDiv.style.display = 'none';
            csvProcessTimeDiv.textContent = '';
        }
        tooltip = d3.select("#tooltip");
        const fileInput = document.getElementById('fileInput');
        const downloadButton = document.getElementById('downloadProcessedDataBtn');
        const applyFiltersBtn = document.getElementById('applyFiltersBtn');
        const sidebarToggleBtn = document.getElementById('sidebar-toggle');
        const resetSidebarBtn = document.getElementById('resetSidebarBtn');
        const sidebarTableContainer = document.getElementById('sidebar-table-container');
        const sidebarGoPageBtn = document.getElementById('sidebarGoPageBtn');
        const sidebarSearchInput = document.getElementById('sidebarTableSearchInput');
        const sidebarFullscreenBtn = document.getElementById('sidebarFullscreenBtn');
        const sidebarNodeSizeMin = document.getElementById('sidebarNodeSizeMin');
        const sidebarNodeSizeMax = document.getElementById('sidebarNodeSizeMax');
        const sidebarEdgeWidthMin = document.getElementById('sidebarEdgeWidthMin');
        const sidebarEdgeWidthMax = document.getElementById('sidebarEdgeWidthMax');
        const metricSelect = document.getElementById('dendrogramSortMetricSelect');
        const thresholdSlider = document.getElementById('thresholdSlider');
        const thresholdValueSpan = document.getElementById('thresholdValue');
        const sidebarLayoutSelect = document.getElementById('sidebarLayoutSelect');
        const applyThresholdBtn = document.getElementById('applyThresholdBtn');
        const reorderTreeCheckbox = document.getElementById('reorderTreeCheckbox');
        const resetGroupingBtn = document.getElementById('resetGroupingBtn');
        const acknowledgeBtn = document.getElementById('acknowledgeNewClustersBtn');
        const messageDivForAcknowledge = document.getElementById('reclusterMessage');
        const saveSelectionBtn = document.getElementById('saveSelectionBtn');
        const cancelLoadingBtn = document.getElementById('cancelLoadingBtn');
        const showSankeyBtn = document.getElementById('showSankeyBtn');
        const sankeyCard = document.getElementById('sankeyCard');
        const showPacketSimilarityBtn = document.getElementById('showPacketSimilarityBtn');
        const refreshIpGraphBtn = document.getElementById('refreshIpGraphBtn');
        const applySankeyToHeatmapBtn = document.getElementById('applySankeyToHeatmapBtn');
        const revertSankeyFilterBtn = document.getElementById('revertSankeyFilterBtn');
        if (applySankeyToHeatmapBtn) {
            applySankeyToHeatmapBtn.addEventListener('click', async () => {
                if (window.activeSankeyNodeFilter) {
                    await updateMainViewAfterSankeyFilter();
                    if (revertSankeyFilterBtn) revertSankeyFilterBtn.disabled = false;
                } else {
                    alert("No Sankey node selected to apply as filter.");
                }
            });
        }
        if (revertSankeyFilterBtn) {
            revertSankeyFilterBtn.addEventListener('click', async () => {
                showLoading();
                try {
                    window.activeSankeyNodeFilter = null;
                    window.sankeyMatchingClusterIds.clear();
                    await loadInlineDendrogram();
                    revertSankeyFilterBtn.disabled = true;
                    if (applySankeyToHeatmapBtn) {
                        applySankeyToHeatmapBtn.disabled = true;
                        applySankeyToHeatmapBtn.style.backgroundColor = "#6c757d";
                    }
                    const sankeySVG = d3.select("#sankey-diagram-container svg");
                    if (!sankeySVG.empty()) {
                        sankeySVG.dispatch('click');
                    }
                } catch (error) {
                    console.error("Error during Sankey filter revert:", error);
                    alert("An error occurred while reverting the filter.");
                } finally {
                    hideLoading();
                }
            });
        }
        window.currentSankeyDimensionsOrder = [...DEFAULT_SANKEY_DIMENSIONS];
        populateSankeyDimensionCheckboxes();
        if (cancelLoadingBtn) {
            cancelLoadingBtn.addEventListener('click', () => {
                if (globalAbortController) {
                    globalAbortController.abort();
                }
                hideLoading();
                const reclusterMessageDiv = document.getElementById('reclusterMessage');
                if (reclusterMessageDiv) {
                    reclusterMessageDiv.textContent = "Operation cancelled by user.";
                    reclusterMessageDiv.style.color = "#757575";
                }
                if (cancelLoadingBtn) cancelLoadingBtn.disabled = true;
            });
        }
        renderSavedItemsList();
        try {
            showLoading();
            await drawTimeline();
            updateLegend();
            await updateHeatmap();
            await updateTimeInfoDisplay();
            if (window.heatmapCountSortOrder && window.heatmapCountSortOrder.length > 0) {
                window.allClusterIdsMasterList = [...new Set(window.heatmapCountSortOrder.map(String))];
            } else {
                if (window.fullHeatmapData && window.fullHeatmapData['Count']) {
                    window.allClusterIdsMasterList = window.fullHeatmapData['Count'].map(d => String(d.cluster));
                } else {
                    window.allClusterIdsMasterList = [];
                }
            }
            await loadInlineDendrogram();
            updateControlsState();
            updateRowOrderSelectState();
        } catch (error) {
            if (error.name !== 'AbortError') {
                console.error("Error during initial page load sequence:", error);
                const dendroCardElement = document.getElementById('dendrogramCard');
                if (dendroCardElement) {
                    const errorDisplay = `<p style="color:red; padding: 20px; text-align:center;">Error loading initial data: ${error.message || 'Unknown error'}. Please try uploading a file.</p>`;
                    const dendroHeader = dendroCardElement.querySelector('.dendro-header');
                    const metaDataLine = document.getElementById('dendrogramMetaDataLine');
                    const svgContainer = document.getElementById('inline-dendrogram-container');
                    const treeControlsDiv = document.getElementById('treeControls');
                    if (dendroHeader) dendroHeader.style.display = 'none';
                    if (metaDataLine) metaDataLine.innerHTML = 'Metadata: Error';
                    if (svgContainer) svgContainer.innerHTML = errorDisplay;
                    if (treeControlsDiv) treeControlsDiv.style.display = 'none';
                    dendroCardElement.style.display = 'block';
                } else {
                    alert(`Error loading initial data: ${error.message || 'Unknown error'}. Please try uploading a file.`);
                }
            } else {
                console.log("Initial page load aborted by user.");
                const dendroCardElement = document.getElementById('dendrogramCard');
                if (dendroCardElement) dendroCardElement.style.display = 'none';
                if (csvProcessTimeDiv) {
                    csvProcessTimeDiv.textContent = 'Initial load cancelled.';
                    csvProcessTimeDiv.style.display = 'block';
                }
            }
        } finally {
            if (!globalAbortController.signal.aborted) {
                hideLoading();
            }
            const page_load_render_end_time = performance.now();
            const duration_s = ((page_load_render_end_time - page_load_render_start_time) / 1000).toFixed(2);
            const localCsvProcessTimeDiv = document.getElementById('csvProcessTime');
            if (localCsvProcessTimeDiv) {
                if (!globalAbortController.signal.aborted && (window.lastTreeData || (window.fullHeatmapData && Object.keys(window.fullHeatmapData).length > 0))) {
                    localCsvProcessTimeDiv.textContent = `Total time to display data: ${duration_s} s`;
                    localCsvProcessTimeDiv.style.display = 'block';
                } else if (globalAbortController.signal.aborted) {} else {
                    localCsvProcessTimeDiv.style.display = 'none';
                    localCsvProcessTimeDiv.textContent = '';
                }
            }
        }
        if (fileInput) {
            fileInput.addEventListener('change', async function(event) {
                const file = event.target.files[0];
                const localProcessingTimeDiv = document.getElementById('csvProcessTime');
                let client_total_processing_start_time;
                if (localProcessingTimeDiv) {
                    localProcessingTimeDiv.style.display = 'none';
                    localProcessingTimeDiv.textContent = '';
                }
                if (file) {
                    if (!file.name.toLowerCase().endsWith('.parquet')) {
                        alert("Invalid file type. Please select a .parquet file.");
                        event.target.value = null;
                        return;
                    }
                    client_total_processing_start_time = performance.now();
                    showLoading();
                    const formData = new FormData();
                    formData.append('file', file);
                    try {
                        const processResponse = await fetch(`${API_BASE_URL}/process_uploaded_file`, {
                            method: 'POST',
                            body: formData,
                            signal: globalAbortController.signal
                        });
                        if (globalAbortController.signal.aborted) throw new DOMException("Operation aborted by user.", "AbortError");
                        if (!processResponse.ok) {
                            const errText = await processResponse.text();
                            let errJson = {};
                            try {
                                errJson = JSON.parse(errText);
                            } catch (e) {}
                            throw new Error(errJson.error || `Processing failed (${processResponse.status}): ${errText.substring(0, 200)}`);
                        }
                        const responseData = await processResponse.json();
                        console.log("File processing response:", responseData);
                        protocolColorMap = {};
                        currentNewClusterIds.clear();
                        window.activeSankeyNodeFilter = null;
                        window.allClusterIdsMasterList = [];
                        const applySankeyBtn = document.getElementById('applySankeyToHeatmapBtn');
                        if (applySankeyBtn) {
                            applySankeyBtn.disabled = true;
                        }
                        if (globalAbortController.signal.aborted) throw new DOMException("Operation aborted by user.", "AbortError");
                        await drawTimeline();
                        updateLegend();
                        if (globalAbortController.signal.aborted) throw new DOMException("Operation aborted by user.", "AbortError");
                        await updateHeatmap();
                        if (window.heatmapCountSortOrder && window.heatmapCountSortOrder.length > 0) {
                            window.allClusterIdsMasterList = [...new Set(window.heatmapCountSortOrder.map(String))];
                        } else {
                            if (window.fullHeatmapData && window.fullHeatmapData['Count']) {
                                window.allClusterIdsMasterList = window.fullHeatmapData['Count'].map(d_item => String(d_item.cluster));
                            } else {
                                window.allClusterIdsMasterList = [];
                            }
                        }
                        if (globalAbortController.signal.aborted) throw new DOMException("Operation aborted by user.", "AbortError");
                        await updateTimeInfoDisplay();
                        if (globalAbortController.signal.aborted) throw new DOMException("Operation aborted by user.", "AbortError");
                        await loadInlineDendrogram();
                        clearSidebarVisualization();
                        clusterHighlightColors.clear();
                        if (isSidebarOpen) toggleSidebar(false);
                        const localThresholdSlider = document.getElementById('thresholdSlider');
                        if (localThresholdSlider && window.lastTreeRoot) {
                            localThresholdSlider.value = 100;
                            const thresholdValueSpan = document.getElementById('thresholdValue');
                            if (thresholdValueSpan) thresholdValueSpan.textContent = '100%';
                            requestAnimationFrame(() => {
                                localThresholdSlider.dispatchEvent(new Event('input'));
                            });
                        }
                        updateControlsState();
                        updateRowOrderSelectState();
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            console.log("File processing aborted by user.");
                            if (localProcessingTimeDiv) {
                                localProcessingTimeDiv.textContent = 'File processing cancelled.';
                                localProcessingTimeDiv.style.display = 'block';
                            }
                        } else {
                            alert(`Error processing Parquet file: ${error.message}`);
                            const dendroCardElem = document.getElementById('dendrogramCard');
                            if (dendroCardElem) dendroCardElem.innerHTML = '<p style="color: red; text-align: center;">Could not process uploaded file.</p>';
                            const metaDataLine = document.getElementById('dendrogramMetaDataLine');
                            if (metaDataLine) metaDataLine.innerHTML = 'Metadata: Error';
                            window.originalTreeData = null;
                            window.lastTreeData = null;
                            window.lastTreeRoot = null;
                            window.fullHeatmapData = {};
                            currentNewClusterIds.clear();
                            window.activeSankeyNodeFilter = null;
                            window.allClusterIdsMasterList = [];
                            updateLegend();
                            clearSidebarVisualization();
                            updateControlsState();
                            updateRowOrderSelectState();
                            if (localProcessingTimeDiv) localProcessingTimeDiv.style.display = 'none';
                        }
                    } finally {
                        const client_total_processing_end_time = performance.now();
                        if (typeof client_total_processing_start_time === 'number') {
                            const duration_ms = client_total_processing_end_time - client_total_processing_start_time;
                            const duration_s = (duration_ms / 1000).toFixed(2);
                            if (!globalAbortController.signal.aborted) {
                                if (localProcessingTimeDiv) {
                                    localProcessingTimeDiv.textContent = `Total time to display data: ${duration_s} s`;
                                    localProcessingTimeDiv.style.display = 'block';
                                }
                            }
                        }
                        if (!globalAbortController.signal.aborted || (globalAbortController.signal.aborted && document.getElementById('loading-overlay').style.display === 'flex')) {
                            hideLoading();
                        }
                    }
                } else {
                    if (localProcessingTimeDiv) {
                        localProcessingTimeDiv.style.display = 'none';
                    }
                }
                if (event.target) event.target.value = null;
            });
        }
        if (downloadButton) {
            downloadButton.addEventListener('click', function() {
                const dataLoadedCheck = window.originalTreeData && Object.keys(window.originalTreeData).length > 0 && !window.originalTreeData.error;
                if (dataLoadedCheck) {
                    window.location.href = `${API_BASE_URL}/download_processed_data`;
                } else {
                    alert("No processed data available to download. Please upload a Parquet file first.");
                }
            });
        }
        if (applyFiltersBtn) {
            applyFiltersBtn.addEventListener('click', async () => {
                showLoading();
                try {
                    window.activeSankeyNodeFilter = null;
                    window.sankeyMatchingClusterIds.clear();
                    if (applySankeyToHeatmapBtn) {
                        applySankeyToHeatmapBtn.disabled = true;
                    }
                    if (revertSankeyFilterBtn) {
                        revertSankeyFilterBtn.disabled = true;
                    }
                    await updateHeatmap();
                    if (globalAbortController.signal.aborted) throw new DOMException("Operation aborted by user.", "AbortError");
                    if (window.heatmapCountSortOrder && window.heatmapCountSortOrder.length > 0) {
                        window.allClusterIdsMasterList = [...new Set(window.heatmapCountSortOrder.map(String))];
                    } else {
                        if (window.fullHeatmapData && window.fullHeatmapData['Count']) {
                            window.allClusterIdsMasterList = window.fullHeatmapData['Count'].map(d => String(d.cluster));
                        } else {
                            window.allClusterIdsMasterList = [];
                        }
                    }
                    await updateTimeInfoDisplay();
                    if (globalAbortController.signal.aborted) throw new DOMException("Operation aborted by user.", "AbortError");
                    await loadInlineDendrogram();
                    if (globalAbortController.signal.aborted) throw new DOMException("Operation aborted by user.", "AbortError");
                    highlightTreeClusters(new Set(clusterHighlightColors.keys()));
                    const localThresholdSlider = document.getElementById('thresholdSlider');
                    if (localThresholdSlider && window.lastTreeRoot) {
                        requestAnimationFrame(() => {
                            localThresholdSlider.dispatchEvent(new Event('input'));
                        });
                    }
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log("Filter application aborted by user.");
                    } else {
                        alert(`Error applying filters: ${error.message || 'Unknown error'}`);
                    }
                } finally {
                    if (!globalAbortController.signal.aborted) hideLoading();
                }
            });
        }
        if (sidebarToggleBtn) {
            sidebarToggleBtn.addEventListener('click', () => toggleSidebar());
        }
        if (resetSidebarBtn) {
            resetSidebarBtn.addEventListener('click', () => {
                console.log("Performing FAST client-side reset.");
                clearSidebarVisualization();
                updateLegend();
                if (window.activeSankeyNodeFilter) {
                    window.activeSankeyNodeFilter = null;
                    window.sankeyMatchingClusterIds.clear();
                    const applyBtn = document.getElementById('applySankeyToHeatmapBtn');
                    const revertBtn = document.getElementById('revertSankeyFilterBtn');
                    if (applyBtn) applyBtn.disabled = true;
                    if (revertBtn) revertBtn.disabled = true;
                    console.log("Sankey filter state cleared on client-side.");
                }
                resetHeatmapHighlights();
                selectedNodeId = null;
                document.getElementById('sidebarLayoutSelect').value = 'cose';
            });
        }
        if (sidebarFullscreenBtn) {
            sidebarFullscreenBtn.addEventListener('click', toggleSidebarFullscreen);
        }
        if (saveSelectionBtn) {
            saveSelectionBtn.addEventListener('click', handleSaveSelection);
        }
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement && isSidebarFullscreen) {
                cleanupFullscreenStyles();
                if (sidebarCy) {
                    setTimeout(() => {
                        sidebarCy.resize();
                        sidebarCy.fit(null, 50);
                    }, 400);
                }
            } else if (document.fullscreenElement === sidebar && !isSidebarFullscreen) {
                isSidebarFullscreen = true;
                sidebar.classList.add('fullscreen');
                legendContainer.classList.add('fullscreen-active');
                document.body.classList.add('sidebar-fullscreen');
                sidebarFullscreenBtn.innerHTML = '&#x274C;';
                sidebarFullscreenBtn.title = "Exit Sidebar Fullscreen";
                if (sidebarCy) {
                    setTimeout(() => {
                        sidebarCy.resize();
                        sidebarCy.fit(null, 50);
                    }, 100);
                }
            }
        });
        if (sidebarTableContainer) {
            sidebarTableContainer.addEventListener('click', handleSidebarTableRowClick);
        }
        if (sidebarSearchInput) {
            sidebarSearchInput.addEventListener('input', filterSidebarTable);
        }
        if (sidebarGoPageBtn) {
            sidebarGoPageBtn.addEventListener('click', function() {
                let pageInput = document.getElementById('sidebarCurrentPageInput');
                let page = parseInt(pageInput.value, 10);
                const totalPagesStr = document.getElementById('sidebarTotalPages').textContent;
                const totalPages = totalPagesStr === '?' ? Infinity : parseInt(totalPagesStr, 10);
                if (!isNaN(page) && page >= 1 && (page <= totalPages || totalPages === Infinity)) {
                    if (sidebarTableMode === 'cluster' && currentSidebarTableClusterId) {
                        loadSidebarClusterTable(currentSidebarTableClusterId, page);
                    } else if (sidebarTableMode === 'edges') {
                        let edgeList = [];
                        if (selectedNodeId && sidebarCy) {
                            const node = sidebarCy.getElementById(selectedNodeId);
                            if (node && node.length > 0) {
                                edgeList = node.connectedEdges().map(edge => ({
                                    source: edge.data('source'),
                                    destination: edge.data('target'),
                                    protocol: edge.data('Protocol')
                                }));
                            }
                        } else if (selectedSidebarEdges.size > 0) {
                            edgeList = Array.from(selectedSidebarEdges).map(key => {
                                const parts = key.split('|');
                                return {
                                    source: parts[0],
                                    destination: parts[1],
                                    protocol: parts[2]
                                };
                            });
                        }
                        if (edgeList.length > 0) {
                            loadSidebarMultiEdgeTable(edgeList, page);
                        } else {
                            console.warn("Sidebar pagination in edge mode, but no edges/nodes identified for table.");
                        }
                    } else {
                        console.warn("Sidebar pagination clicked, but table context (cluster/edge) is unclear or no target ID.");
                    }
                } else {
                    alert(`Please enter a valid page number between 1 and ${totalPagesStr}.`);
                }
            });
        }
        if (sidebarLayoutSelect) {
            sidebarLayoutSelect.addEventListener('change', applySidebarLayout);
        }
        if (sidebarNodeSizeMin) sidebarNodeSizeMin.addEventListener('input', applySidebarSizeControls);
        if (sidebarNodeSizeMax) sidebarNodeSizeMax.addEventListener('input', applySidebarSizeControls);
        if (sidebarEdgeWidthMin) sidebarEdgeWidthMin.addEventListener('input', applySidebarSizeControls);
        if (sidebarEdgeWidthMax) sidebarEdgeWidthMax.addEventListener('input', applySidebarSizeControls);
        if (metricSelect) {
            metricSelect.addEventListener('change', () => {
                updateRowOrderSelectState();
                if (window.lastTreeData) {
                    showLoading();
                    try {
                        showInlineDendrogram(window.lastTreeData, document.getElementById("inline-dendrogram-container").clientHeight, currentNewClusterIds);
                        highlightTreeClusters(new Set(clusterHighlightColors.keys()));
                        const localThresholdSlider = document.getElementById('thresholdSlider');
                        requestAnimationFrame(() => {
                            if (localThresholdSlider && window.lastTreeRoot) localThresholdSlider.dispatchEvent(new Event('input'));
                        });
                    } catch (error) {
                        if (error.name !== 'AbortError') console.error("Error reloading dendrogram on metric change:", error);
                    } finally {
                        if (!globalAbortController.signal.aborted) hideLoading();
                    }
                }
            });
        }
        const rowOrderSelect = document.getElementById("rowOrderSelect");
        if (rowOrderSelect && metricSelect) {
            rowOrderSelect.addEventListener('change', () => {
                if (metricSelect.value !== 'Default' && window.lastTreeData) {
                    showLoading();
                    try {
                        showInlineDendrogram(window.lastTreeData, document.getElementById("inline-dendrogram-container").clientHeight, currentNewClusterIds);
                        highlightTreeClusters(new Set(clusterHighlightColors.keys()));
                        const localThresholdSlider = document.getElementById('thresholdSlider');
                        requestAnimationFrame(() => {
                            if (localThresholdSlider && window.lastTreeRoot) localThresholdSlider.dispatchEvent(new Event('input'));
                        });
                    } catch (error) {
                        if (error.name !== 'AbortError') console.error("Error reloading dendrogram on row order change:", error);
                    } finally {
                        if (!globalAbortController.signal.aborted) hideLoading();
                    }
                }
            });
        }
        if (reorderTreeCheckbox) {
            reorderTreeCheckbox.addEventListener('change', () => {
                if (window.lastTreeData) {
                    showLoading();
                    try {
                        showInlineDendrogram(window.lastTreeData, document.getElementById("inline-dendrogram-container").clientHeight, currentNewClusterIds);
                        highlightTreeClusters(new Set(clusterHighlightColors.keys()));
                        const localThresholdSlider = document.getElementById('thresholdSlider');
                        requestAnimationFrame(() => {
                            if (localThresholdSlider && window.lastTreeRoot) localThresholdSlider.dispatchEvent(new Event('input'));
                        });
                    } catch (error) {
                        if (error.name !== 'AbortError') console.error("Error reloading dendrogram on reorder checkbox change:", error);
                    } finally {
                        if (!globalAbortController.signal.aborted) hideLoading();
                    }
                }
            });
        }
        if (thresholdSlider && thresholdValueSpan) {
            thresholdSlider.addEventListener('input', function() {
                const physicalValue = parseInt(this.value, 10);
                const currentMaxDistForDisplay = window.lastAppliedThreshold || 100;
                const scaledPercentage = Math.round((physicalValue / 100) * currentMaxDistForDisplay);
                thresholdValueSpan.textContent = `${scaledPercentage}%`;
                const svgContent = d3.select("#inlineDendrogramSvg g");
                const thresholdBar = d3.select("#threshold-bar");
                if (!window.lastTreeRoot || svgContent.empty() || thresholdBar.empty()) {
                    if (thresholdBar && !thresholdBar.empty()) thresholdBar.style("display", "none");
                    return;
                }
                const layoutHeight = window.currentD3LayoutHeight;
                const currentD3MarginTop = (typeof margin !== 'undefined' && margin.top) ? margin.top : 30;
                if (layoutHeight && layoutHeight > 0) {
                    const thresholdY_untransformed = layoutHeight * (physicalValue / 100) + currentD3MarginTop;
                    const currentTransform = d3.zoomTransform(d3.select("#inlineDendrogramSvg").node());
                    const transformedY = currentTransform.applyY(thresholdY_untransformed);
                    const currentD3MarginLeft = (typeof margin !== 'undefined' && margin.left) ? margin.left : 30;
                    const currentD3MarginRight = (typeof margin !== 'undefined' && margin.right) ? margin.right : 30;
                    thresholdBar.attr("x1", currentTransform.applyX(0)).attr("x2", currentTransform.applyX((window.currentLayoutWidth || 0) + currentD3MarginLeft + currentD3MarginRight)).attr("y1", transformedY).attr("y2", transformedY).style("display", "block");
                } else {
                    thresholdBar.style("display", "none");
                }
            });
        }
        if (applyThresholdBtn) {
            applyThresholdBtn.addEventListener('click', applyThresholdGrouping);
        }
        if (resetGroupingBtn) {
            resetGroupingBtn.addEventListener('click', resetGroupingAndRedraw);
        }
        const mainGoPageBtn = document.getElementById('goPageBtn');
        if (mainGoPageBtn) {
            mainGoPageBtn.addEventListener('click', function() {
                let pageInput = document.getElementById('currentPageInput');
                let page = parseInt(pageInput.value, 10);
                const totalPagesStr = document.getElementById('totalPages').textContent;
                const totalPages = totalPagesStr === '?' ? Infinity : parseInt(totalPagesStr, 10);
                if (!isNaN(page) && page >= 1 && (page <= totalPages || totalPages === Infinity) && currentClusterID) {
                    loadClusterTablePage(currentClusterID, page);
                } else {
                    alert(`Please enter a valid page number between 1 and ${totalPagesStr}.`);
                }
            });
        }
        const mainTableSearchInput = document.getElementById('tableSearchInput');
        if (mainTableSearchInput) {
            mainTableSearchInput.addEventListener('input', function() {
                console.log("Main table search not active for this view (placeholder).");
            });
        }
        if (acknowledgeBtn && messageDivForAcknowledge) {
            acknowledgeBtn.addEventListener('click', () => {
                messageDivForAcknowledge.textContent = '';
                acknowledgeBtn.style.display = 'none';
                currentNewClusterIds.clear();
                if (window.lastTreeData) {
                    showInlineDendrogram(window.lastTreeData, document.getElementById("inline-dendrogram-container").clientHeight, currentNewClusterIds);
                }
            });
        }
        if (showPacketSimilarityBtn) {
            showPacketSimilarityBtn.addEventListener('click', function() {
                const card = document.getElementById('packetSimilarityCard');
                if (!card) return;
                if (card.style.display === 'none' || card.style.display === '') {
                    const dataLoadedCheck = window.originalTreeData && Object.keys(window.originalTreeData).length > 0 && !window.originalTreeData.error;
                    if (!dataLoadedCheck) {
                        alert("Please upload data first.");
                        return;
                    }
                    card.style.display = 'block';
                    this.textContent = 'Hide IP Community Graph';
                    fetchAndRenderLouvainIpGraph();
                } else {
                    card.style.display = 'none';
                    this.textContent = 'Show Community IP Graph';
                    if (window.louvainIpCy) {
                        window.louvainIpCy.destroy();
                        window.louvainIpCy = null;
                    }
                }
            });
        }
        if (refreshIpGraphBtn) {
            refreshIpGraphBtn.addEventListener('click', fetchAndRenderLouvainIpGraph);
        }
        if (showSankeyBtn) {
            showSankeyBtn.addEventListener('click', function() {
                if (!sankeyCard) {
                    return;
                }
                if (sankeyCard.style.display === 'none' || sankeyCard.style.display === '') {
                    const dataLoadedCheckSankey = window.originalTreeData && Object.keys(window.originalTreeData).length > 0 && !window.originalTreeData.error;
                    if (!dataLoadedCheckSankey) {
                        alert("Please upload and process a file first to generate data for the Sankey diagram.");
                        return;
                    }
                    sankeyCard.style.display = 'block';
                    this.textContent = 'Hide Sankey Diagram';
                    fetchAndRenderSankeyDiagram();
                } else {
                    sankeyCard.style.display = 'none';
                    this.textContent = 'Show Sankey Diagram';
                    window.activeSankeyNodeFilter = null;
                    window.sankeyMatchingClusterIds.clear();
                    if (applySankeyToHeatmapBtn) {
                        applySankeyToHeatmapBtn.disabled = true;
                    }
                    if (revertSankeyFilterBtn) {
                        revertSankeyFilterBtn.disabled = true;
                    }
                    if (window.lastTreeData) {
                        loadInlineDendrogram();
                    }
                }
            });
        }
        if (applySankeyToHeatmapBtn) {
            applySankeyToHeatmapBtn.addEventListener('click', () => {
                if (window.activeSankeyNodeFilter) {
                    updateMainViewAfterSankeyFilter().then(() => {
                        if (revertSankeyFilterBtn) {
                            revertSankeyFilterBtn.disabled = false;
                        }
                    });
                } else {
                    alert("No Sankey node selected to apply as filter.");
                }
            });
        }
        document.getElementById('entropyMinFilter').style.display = 'none';
        document.getElementById('entropyMaxFilter').style.display = 'none';
        document.querySelector('label[for="entropyMinFilter"]').style.display = 'none';
        document.querySelector('label[for="entropyMaxFilter"]').style.display = 'none';
    });

    function showInlineDendrogram(data, svgH = 400, newClusterIds = new Set()) {
        const containerDiv = document.getElementById("inline-dendrogram-container");
        const dendrogramCard = document.getElementById('dendrogramCard');
        const treeControls = document.getElementById('treeControls');
        const reorderCheckbox = document.getElementById('reorderTreeCheckbox');
        const svg = d3.select("#inlineDendrogramSvg");
        
        const metaDataLineDiv = document.getElementById('dendrogramMetaDataLine');

        svg.selectAll("*").remove(); 
        if (metaDataLineDiv) metaDataLineDiv.innerHTML = '';

        svg.append("line").attr("id", "threshold-bar")
            .attr("stroke", "rgba(220, 53, 69, 0.7)")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "5 3")
            .style("pointer-events", "none")
            .style("display", "none");

        const highlightStrokeWidth = 1.5;
        const defaultStrokeColor = '#fff';
        const defaultStrokeWidth = 0.2;
        const anomalyOverrideColor = "orange";
        const minBlueIntensity = 0.05;
        const customBluesInterpolator = t_val => d3.interpolateBlues(minBlueIntensity + Math.max(0, Math.min(1, t_val)) * (1 - minBlueIntensity));
        const minGreenIntensity = 0.15;
        const customGreensInterpolator = t_val => d3.interpolateGreens(minGreenIntensity + Math.max(0, Math.min(1, t_val)) * (1 - minGreenIntensity));
        
        const blueColorScales = {}; 
        const greenColorScales = {};

        if (!containerDiv || !dendrogramCard || !treeControls || !reorderCheckbox || !svg.node()) {
            if(dendrogramCard) dendrogramCard.style.display = 'block';
            if(containerDiv) containerDiv.style.height = `${svgH}px`;
            svg.append("text").attr("x", "50%").attr("y", "50%").attr("text-anchor", "middle").attr("dominant-baseline", "central")
                .text("Error: Cannot calculate layout - missing elements.");
            if(treeControls) treeControls.style.display = "none";
            if (metaDataLineDiv) metaDataLineDiv.innerHTML = 'Error displaying metadata.';
            window.lastTreeRoot = null;
            window.lastTreeData = null;
            return;
        }

        dendrogramCard.style.display = 'block';

        let calculatedHeight = svgH;
        if (typeof svgH !== 'number' || svgH < 200) {
            try {
                const viewportHeight = window.innerHeight;
                const cardRect = dendrogramCard.getBoundingClientRect();
                const cardTopOffset = cardRect.top;
                const cardStyle = window.getComputedStyle(dendrogramCard);
                const cardMarginBottom = parseFloat(cardStyle.marginBottom) || 0;
                const cardPaddingTop = parseFloat(cardStyle.paddingTop) || 0;
                const cardPaddingBottom = parseFloat(cardStyle.paddingBottom) || 0;
                const controlsHeight = treeControls.offsetHeight || 50; 
                const estimatedTopSectionHeight = document.querySelector('#dendrogramCard .dendro-header')?.offsetHeight || 70;
                const containerStyle = window.getComputedStyle(containerDiv);
                const containerMarginBottom = parseFloat(containerStyle.marginBottom) || 10;
                const safetyMargin = 30; 
                const spaceBelowCardTop = viewportHeight - cardTopOffset - cardMarginBottom - safetyMargin;
                const availableHeight = spaceBelowCardTop - cardPaddingTop - estimatedTopSectionHeight - containerMarginBottom - controlsHeight - cardPaddingBottom;
                calculatedHeight = Math.max(250, Math.min(availableHeight, viewportHeight * 0.75));
            } catch (e) {
                console.warn("Could not calculate dynamic dendrogram height, using default.", e);
                calculatedHeight = 400; // A fixed fallback default
            }
        }
        window.currentDendrogramHeight = calculatedHeight;
        svgH = calculatedHeight; 
        containerDiv.style.height = `${svgH}px`;

        if (!data || data.id === undefined || data.is_minimal === true || (data.children && data.children.length === 0 && data.id && data.cluster_id) || data.no_tree || data.error ) {
            let message = "No hierarchical data available or error loading.";
            let metaPartsForEmpty = [];
            let clusterInfoText = '0 Clusters';
            let packetInfoText = "Packets: N/A";

            if (data && data.is_minimal === true) {
                message = `Tree cannot be built: Only one cluster (${data.cluster_id || 'N/A'}) found.`;
                clusterInfoText = `1 Cluster (${data.cluster_id || 'N/A'})`;
                if (window.fullHeatmapData && window.fullHeatmapData['Count'] && data.cluster_id) {
                    const singleClusterEntry = window.fullHeatmapData['Count'].find(entry => String(entry.cluster) === String(data.cluster_id));
                    if (singleClusterEntry && typeof singleClusterEntry.value === 'number') {
                        packetInfoText = `Packets: ${singleClusterEntry.value.toLocaleString()}`;
                    }
                }
            } else if (data && data.error) { 
                message = `Error loading tree data: ${data.error}`;
            } else if (data && data.id && (!data.children || data.children.length === 0) && data.cluster_id) {
                message = `Tree cannot be built: Only one cluster (${data.cluster_id}) found.`;
                clusterInfoText = `1 Cluster (${data.cluster_id})`;
                if (window.fullHeatmapData && window.fullHeatmapData['Count'] && data.cluster_id) {
                    const singleClusterEntry = window.fullHeatmapData['Count'].find(entry => String(entry.cluster) === String(data.cluster_id));
                    if (singleClusterEntry && typeof singleClusterEntry.value === 'number') {
                        packetInfoText = `Packets: ${singleClusterEntry.value.toLocaleString()}`;
                    }
                }
            }
            
            metaPartsForEmpty.push(clusterInfoText);
            if (typeof currentDisplayableTimeInfo !== 'undefined' && currentDisplayableTimeInfo.isSet) {
                metaPartsForEmpty.push(currentDisplayableTimeInfo.start);
                metaPartsForEmpty.push(currentDisplayableTimeInfo.end);
                metaPartsForEmpty.push(currentDisplayableTimeInfo.duration);
            } else {
                metaPartsForEmpty.push("Start: N/A");
                metaPartsForEmpty.push("End: N/A");
                metaPartsForEmpty.push("Duration: N/A");
            }
            metaPartsForEmpty.push(packetInfoText);

            svg.append("text").attr("x", "50%").attr("y", "50%").attr("text-anchor", "middle").attr("dominant-baseline", "central").style("font-size", "16px").style("fill", "#555").text(message);
            if (treeControls) treeControls.style.display = "none";
            
            if (metaDataLineDiv) {
                const separator = "&nbsp;&nbsp;|&nbsp;&nbsp;";
                metaDataLineDiv.innerHTML = metaPartsForEmpty.filter(p => p).join(separator);
            }
            window.lastTreeRoot = null; window.lastTreeData = null;
            console.warn("showInlineDendrogram: Not enough data to draw a tree or error. Displaying message:", message);
            return;
        }

        const internalTopMargin = 15; 
        const internalBottomMargin = 20;
        const dendrogramHeightInternal = Math.max(150, svgH - internalTopMargin - internalBottomMargin); 
        const height = dendrogramHeightInternal; 
        window.currentD3LayoutHeight = height;

        const features = (typeof metrics !== 'undefined' && Array.isArray(metrics)) ? metrics.map(m => m.label) : [];
        const numHeatmapFeatures = features.length;
        const heatmapRowHeight = 15; 
        const heatmapSpacing = 5;   

        const featureScale = d3.scaleBand().domain(features).paddingInner(0.1); 
        const heatmapContentStartY = height + heatmapSpacing + margin.top;
        const approximateHeatmapContentHeight = numHeatmapFeatures * heatmapRowHeight;
        featureScale.range([heatmapContentStartY, heatmapContentStartY + approximateHeatmapContentHeight]);
        const finalHeatmapBlockHeight = (numHeatmapFeatures > 0) ? (featureScale.step() * numHeatmapFeatures) : 0;
        const heatmapStartY = height + heatmapSpacing + margin.top; 
        const heatmapEndY = heatmapStartY + finalHeatmapBlockHeight - (numHeatmapFeatures > 0 ? featureScale.paddingInner() * featureScale.step() : 0); 

        const root = d3.hierarchy(data);
        const currentLeaves = root.leaves();
        const leafCount = currentLeaves.length;
        
        const treeLayout = d3.cluster().size([1, height]); 
        treeLayout(root);

        root.each(node => {
            node.structuralY = node.y; 
            if (typeof node.structuralY !== 'number' || !isFinite(node.structuralY)) {
                node.structuralY = (node.parent && typeof node.parent.structuralY === 'number' && isFinite(node.parent.structuralY)) ? node.parent.structuralY : 0;
            }
            node.finalY = node.structuralY;
        });

        const structuralLeaves = [...currentLeaves].sort((a, b) => a.x - b.x); 
        const structuralClusterOrGroupIds = structuralLeaves.map(leaf => leaf.data?.cluster_id).filter(id => id !== undefined && id !== null).map(String);
        const minLeafSpacingStructural = 20; 
        const requiredWidthStructural = structuralClusterOrGroupIds.length * minLeafSpacingStructural;
        const containerWidth = containerDiv.clientWidth || 600;
        const widthAvailableInContainer = Math.max(300, containerWidth - margin.left - margin.right);
        const structuralLayoutWidth = Math.max(requiredWidthStructural, widthAvailableInContainer);
        const structuralXScale = d3.scaleBand().domain(structuralClusterOrGroupIds).range([margin.left, margin.left + structuralLayoutWidth]).paddingInner(0); 

        root.eachAfter(node => { 
            if (node.children && node.children.length > 0) {
                const validChildrenX = node.children.map(c => c.structuralX).filter(x => typeof x === 'number' && isFinite(x) && x >= 0);
                if (validChildrenX.length > 0) { node.structuralX = d3.mean(validChildrenX); } 
                else { node.structuralX = (structuralLayoutWidth / 2 + margin.left); } 
            } else { 
                const id = node.data?.cluster_id;
                if (id !== undefined && id !== null) {
                    const bandStart = structuralXScale(String(id));
                    if (bandStart !== undefined && typeof bandStart === 'number') { node.structuralX = bandStart + structuralXScale.bandwidth() / 2; } 
                    else { node.structuralX = -1000; } 
                } else { node.structuralX = -1000; } 
            }
            if (typeof node.structuralX !== 'number' || !isFinite(node.structuralX)) { node.structuralX = (structuralLayoutWidth / 2 + margin.left); }
        });

        let metricSortedLeaves = [...currentLeaves];
        const metricSelectElem = document.getElementById('dendrogramSortMetricSelect');
        const selectedMetric = metricSelectElem ? metricSelectElem.value : 'Default';
        
        const aggregatedLeafData = new Map();
        currentLeaves.forEach(leaf => {
            const leafId = leaf.data?.cluster_id;
            if (!leafId) return;
            const stringLeafId = String(leafId);
            aggregatedLeafData.set(stringLeafId, {});
            
            if (leaf.data.isGroup) {
                const originalLeafIds = Array.from(leaf.data.originalLeaves || []);
                if (originalLeafIds.length === 0) { 
                    features.forEach(metricLabel => { 
                        aggregatedLeafData.get(stringLeafId)[metricLabel] = null; 
                        aggregatedLeafData.get(stringLeafId)[`${metricLabel}_anomaly`] = 'normal'; 
                    }); 
                    return; 
                }
                const originalDataForGroup = new Map(); 
                let totalPacketCountInGroup = 0;

                originalLeafIds.forEach(origId => {
                    features.forEach(metricLabel => {
                        const metricStore = window.fullHeatmapData[metricLabel] || [];
                        const originalEntry = metricStore.find(entry => String(entry.cluster) === String(origId));
                        const value = originalEntry?.value !== undefined ? parseFloat(originalEntry.value) : null;
                        const anomaly = originalEntry?.clusterAnomaly || 'normal';
                        let packetCountForWeighting = 1; 
                        if (window.fullHeatmapData['Count']) { 
                            const countEntryForWeight = window.fullHeatmapData['Count'].find(entry => String(entry.cluster) === String(origId)); 
                            packetCountForWeighting = countEntryForWeight ? (parseFloat(countEntryForWeight.value) || 1) : 1; 
                        }
                        if (!originalDataForGroup.has(metricLabel)) originalDataForGroup.set(metricLabel, []);
                        if (value !== null && !isNaN(value)) { 
                            originalDataForGroup.get(metricLabel).push({ value: value, anomaly: anomaly, count: packetCountForWeighting }); 
                        } else { 
                            originalDataForGroup.get(metricLabel).push({ value: null, anomaly: anomaly, count: packetCountForWeighting }); 
                        }
                    });
                    if (window.fullHeatmapData['Count']) { 
                        const countEntry = window.fullHeatmapData['Count'].find(entry => String(entry.cluster) === String(origId)); 
                        totalPacketCountInGroup += countEntry ? (parseFloat(countEntry.value) || 0) : 0;
                    } else { 
                        totalPacketCountInGroup += 1; 
                    } 
                });

                features.forEach(metricLabel => {
                    const valuesAndCounts = originalDataForGroup.get(metricLabel)?.filter(d_item => d_item.value !== null) || [];
                    const allEntries = originalDataForGroup.get(metricLabel) || [];
                    let aggregatedValue = null; 
                    let aggregatedAnomaly = 'normal';
                    if (allEntries.some(d_item => d_item.anomaly === 'anomaly')) aggregatedAnomaly = 'anomaly';

                    if (metricLabel === 'Count') {
                        aggregatedValue = totalPacketCountInGroup;
                    } else if (valuesAndCounts.length > 0) {
                        switch (metricLabel) {
                            case 'Total Data Sent': aggregatedValue = d3.sum(valuesAndCounts, d_item => d_item.value); break;
                            case '% SYN packets': case '% RST packets': case '% ACK packets': case '% PSH packets': case 'Average Inter-Arrival Time':
                                const totalValueSum = d3.sum(valuesAndCounts, d_item => d_item.value * d_item.count);
                                const totalWeightSum = d3.sum(valuesAndCounts, d_item => d_item.count);
                                aggregatedValue = totalWeightSum > 0 ? totalValueSum / totalWeightSum : d3.mean(valuesAndCounts, d_item => d_item.value); break;
                            case 'Unique IPs': case 'Unique Sources': case 'Unique Destinations': aggregatedValue = d3.sum(valuesAndCounts, d_item => d_item.value); break; 
                            case 'Payload Size Variance': case 'Packets per Second': aggregatedValue = d3.mean(valuesAndCounts, d_item => d_item.value); break;
                            case 'Start Time': aggregatedValue = d3.min(valuesAndCounts, d_item => d_item.value); break;
                            case 'Duration': aggregatedValue = d3.max(valuesAndCounts, d_item => d_item.value); break;
                            case 'Length': case 'Len': aggregatedValue = d3.mean(valuesAndCounts, d_item => d_item.value); break;
                            default: aggregatedValue = d3.mean(valuesAndCounts, d_item => d_item.value); break;
                        }
                    }
                    aggregatedLeafData.get(stringLeafId)[metricLabel] = aggregatedValue;
                    aggregatedLeafData.get(stringLeafId)[`${metricLabel}_anomaly`] = aggregatedAnomaly;
                });
            } else { 
                features.forEach(metricLabel => {
                    const metricStore = window.fullHeatmapData[metricLabel] || [];
                    const originalEntry = metricStore.find(entry => String(entry.cluster) === stringLeafId);
                    const value = originalEntry?.value !== undefined ? parseFloat(originalEntry.value) : null;
                    const anomaly = originalEntry?.clusterAnomaly || 'normal';
                    aggregatedLeafData.get(stringLeafId)[metricLabel] = (value !== null && !isNaN(value)) ? value : null;
                    aggregatedLeafData.get(stringLeafId)[`${metricLabel}_anomaly`] = anomaly;
                });
            }
        });
        
        if (metaDataLineDiv) {
            let metaDataParts = [];
            let clusterInfoText = `${leafCount} Clusters`;
            if (window.currentGroupingApplied && typeof window.originalLeafCount === 'number' && window.originalLeafCount > 0) {
                clusterInfoText = `${leafCount} Clusters (Original ${window.originalLeafCount})`;
            }
            metaDataParts.push(clusterInfoText);

            if (typeof currentDisplayableTimeInfo !== 'undefined' && currentDisplayableTimeInfo.isSet) {
                metaDataParts.push(currentDisplayableTimeInfo.start);
                metaDataParts.push(currentDisplayableTimeInfo.end);
                metaDataParts.push(currentDisplayableTimeInfo.duration);
            } else {
                metaDataParts.push("Start: N/A");
                metaDataParts.push("End: N/A");
                metaDataParts.push("Duration: N/A");
            }

            let totalPacketCountDendro = 0;
            let packetCountAvailable = false;
            if (aggregatedLeafData.size > 0) {
                currentLeaves.forEach(leaf => {
                    const leafIdStr = String(leaf.data?.cluster_id);
                    if (leafIdStr) {
                        const leafAggEntry = aggregatedLeafData.get(leafIdStr);
                        if (leafAggEntry && typeof leafAggEntry['Count'] === 'number') {
                            totalPacketCountDendro += leafAggEntry['Count'];
                            packetCountAvailable = true; 
                        }
                    }
                });
            }
            
            if (packetCountAvailable) {
                metaDataParts.push(`Packets: ${totalPacketCountDendro.toLocaleString()}`);
            } else {
                metaDataParts.push("Packets: N/A");
            }
            
            const separator = "&nbsp;&nbsp;|&nbsp;&nbsp;";
            metaDataLineDiv.innerHTML = metaDataParts.filter(p => p).join(separator);
        }


        if (selectedMetric !== 'Default' && window.fullHeatmapData && window.fullHeatmapData[selectedMetric]) {
            metricSortedLeaves.sort((a, b) => {
                const aId = String(a.data?.cluster_id); const bId = String(b.data?.cluster_id);
                const aData = aggregatedLeafData.get(aId); const bData = aggregatedLeafData.get(bId);
                const aValue = aData ? (aData[selectedMetric] ?? null) : null;
                const bValue = bData ? (bData[selectedMetric] ?? null) : null;
                if (aValue === null && bValue === null) return 0; if (aValue === null) return 1; if (bValue === null) return -1; 
                const orderOption = document.getElementById("rowOrderSelect")?.value || "descending";
                return orderOption === "descending" ? bValue - aValue : aValue - bValue;
            });
        } else { 
            metricSortedLeaves.sort((a,b) => a.x - b.x); 
        }

        const heatmapClusterOrGroupIds = metricSortedLeaves.map(leaf => leaf.data?.cluster_id).filter(id => id !== undefined && id !== null).map(String);
        const reorderTree = reorderCheckbox.checked;
        let finalLayoutWidth;

        if (reorderTree) {
            const minLeafSpacingMetric = 20; const requiredWidthMetric = heatmapClusterOrGroupIds.length * minLeafSpacingMetric;
            finalLayoutWidth = Math.max(requiredWidthMetric, widthAvailableInContainer);
            const metricXScale = d3.scaleBand().domain(heatmapClusterOrGroupIds).range([margin.left, margin.left + finalLayoutWidth]).paddingInner(0);
            root.eachAfter(node => { 
                if (node.children && node.children.length > 0) {
                    const validChildrenX = node.children.map(c => c.finalX).filter(x => typeof x === 'number' && isFinite(x) && x >= 0);
                    if (validChildrenX.length > 0) { node.finalX = d3.mean(validChildrenX); } else { node.finalX = (finalLayoutWidth / 2 + margin.left); }
                } else { 
                    const id = node.data?.cluster_id;
                    if (id !== undefined && id !== null) { const bandStart = metricXScale(String(id)); if (bandStart !== undefined && typeof bandStart === 'number') node.finalX = bandStart + metricXScale.bandwidth() / 2; else node.finalX = -1000; } 
                    else node.finalX = -1000;
                }
                if (typeof node.finalX !== 'number' || !isFinite(node.finalX)) node.finalX = (finalLayoutWidth / 2 + margin.left);
            });
        } else { 
            finalLayoutWidth = structuralLayoutWidth;
            root.each(node => { node.finalX = node.structuralX; if (typeof node.finalX !== 'number' || !isFinite(node.finalX)) node.finalX = (finalLayoutWidth / 2 + margin.left); });
        }
        window.currentLayoutWidth = finalLayoutWidth; window.lastTreeRoot = root; window.lastTreeData = data; 
        const heatmapContentWidth = finalLayoutWidth; 
        const heatmapXScale = d3.scaleBand().domain(heatmapClusterOrGroupIds).range([margin.left, margin.left + heatmapContentWidth]).paddingInner(0); 

        const totalNeededHeightForViewBox = height + (finalHeatmapBlockHeight > 0 ? finalHeatmapBlockHeight + heatmapSpacing : 0) + margin.top + margin.bottom;
        const viewBoxHeight = totalNeededHeightForViewBox;
        const viewBoxWidth = finalLayoutWidth + margin.left + margin.right; 
        svg.attr("viewBox", `0 0 ${viewBoxWidth} ${viewBoxHeight}`).attr("preserveAspectRatio", "xMidYMid meet");

        const svgContent = svg.append("g"); 
        const linkGroup = svgContent.append("g").attr("class", "links-group");
        const nodeDrawingGroup = svgContent.append("g").attr("class", "nodes-group");
        const heatmapCellGroup = svgContent.append("g").attr("class", "heatmap-cells-group");
        const heatmapLineGroup = svgContent.append("g").attr("class", "heatmap-lines-group");
        const heatmapLabelGroup = svgContent.append("g").attr("class", "heatmap-labels-group");

        linkGroup.selectAll(".link").data(root.links()).join("path").attr("class", "link")
            .attr("d", d_link => {
                const sourceX = d_link.source.finalX; const sourceY = d_link.source.finalY + margin.top;
                const targetX = d_link.target.finalX; const targetY = d_link.target.finalY + margin.top;
                if ([sourceX, sourceY, targetX, targetY].every(coord => typeof coord === 'number' && isFinite(coord))) {
                    const midY = sourceY + (targetY - sourceY) / 2;
                    return `M${sourceX},${sourceY} L${sourceX},${midY} L${targetX},${midY} L${targetX},${targetY}`;
                } return "";
            }).attr("fill", "none").attr("stroke", "#ccc").attr("stroke-width", 1.5);

        const drawnNodes = nodeDrawingGroup.selectAll(".node")
            .data(root.descendants().filter(d_node => typeof d_node.finalX === 'number' && isFinite(d_node.finalX) && typeof d_node.finalY === 'number' && isFinite(d_node.finalY)))
            .join("g").attr("class", d_node => "node" + (d_node.children ? " node--internal" : " node--leaf") + (d_node.data.isGroup ? " node--group" : ""))
            .attr("transform", d_node => `translate(${d_node.finalX},${d_node.finalY + margin.top})`);
        drawnNodes.append("circle").attr("r", 4)
            .style("fill", d_node => d_node.data.isGroup ? "#a0a0a0" : (d_node.children ? "#555" : "#999"))
            .style("stroke", d_node => d_node.data.isGroup ? "#555" : "none").style("stroke-width", d_node => d_node.data.isGroup ? 1 : 0);

        if (features.length > 0 && heatmapClusterOrGroupIds.length > 0 && aggregatedLeafData.size > 0) {
            const heatmapFeatureData = [];
            heatmapClusterOrGroupIds.forEach(leafId => {
                const leafAggData = aggregatedLeafData.get(String(leafId)); 
                if (leafAggData) {
                    const leafNode = currentLeaves.find(l_node => String(l_node.data?.cluster_id) === String(leafId));
                    const isGroup = leafNode?.data?.isGroup || false;
                    // =================== START OF CORRECTED CODE ===================
                    // FIX: Use .length for Arrays, not .size. The data structure was converted to an Array earlier.
                    const originalLeavesCount = isGroup ? (leafNode.data.originalLeaves?.length || 0) : 1;
                    // =================== END OF CORRECTED CODE ===================
                    const isNewCluster = newClusterIds.has(String(leafId));
                    features.forEach(metricLabel => {
                        heatmapFeatureData.push({
                            cluster_id: leafId, feature: metricLabel, value: leafAggData[metricLabel] ?? null, 
                            anomaly: leafAggData[`${metricLabel}_anomaly`] || 'normal',
                            isGroup: isGroup, originalLeavesCount: originalLeavesCount, isNew: isNewCluster
                        });
                    });
                }
            });
            
            features.forEach(metricLabel => {
                const numericValues = heatmapFeatureData.filter(d_filter => d_filter.feature === metricLabel && d_filter.value !== null && typeof d_filter.value === 'number' && isFinite(d_filter.value)).map(d_map => d_map.value);
                let domain = [0, 1];
                if (numericValues.length > 0) { const rowMin = d3.min(numericValues); const rowMax = d3.max(numericValues); domain = [Math.min(0, rowMin), Math.max(rowMax, rowMin + 1e-9)]; }
                blueColorScales[metricLabel] = d3.scaleSequential(customBluesInterpolator).domain(domain).clamp(true);
                greenColorScales[metricLabel] = d3.scaleSequential(customGreensInterpolator).domain(domain).clamp(true);
            });

            featureScale.range([heatmapStartY, heatmapEndY]);

            if (heatmapXScale.bandwidth() > 0 && featureScale.bandwidth() > 0) {
                const cellSelection = heatmapCellGroup.selectAll(".heatmap-cell")
                    .data(heatmapFeatureData, d_data => `${d_data.cluster_id}-${d_data.feature}`)
                    .join("rect").attr("class", "heatmap-cell")
                    .attr("x", d_attr => { const xVal = heatmapXScale(d_attr.cluster_id); return (typeof xVal === 'number' && isFinite(xVal)) ? xVal : -1000; })
                    .attr("width", heatmapXScale.bandwidth())
                    .attr("y", d_attr => { const yVal = featureScale(d_attr.feature); return (typeof yVal === 'number' && isFinite(yVal)) ? yVal : -1000; })
                    .attr("height", featureScale.bandwidth());

                cellSelection.filter(function() { const x = +d3.select(this).attr("x"); const y = +d3.select(this).attr("y"); return x >= -margin.left && y >= 0; })
                    .each(function(d_cell) {
                        const cell = d3.select(this);
                        let currentFill;
                        let activeScale;
                        const cellClusterIdStr = String(d_cell.cluster_id);
                        // Check if this cluster is part of the current Sankey selection
                        const isClusterSankeyMatched = window.activeSankeyNodeFilter && window.sankeyMatchingClusterIds.has(cellClusterIdStr);

                        cell.style("opacity", 1.0);

                        // Determine which color scale to use: green for Sankey-matched, blue otherwise
                        if (isClusterSankeyMatched) {
                            activeScale = greenColorScales[d_cell.feature];
                        } else {
                            activeScale = blueColorScales[d_cell.feature];
                        }

                        // Determine the final fill color
                        // Anomaly (orange) overrides blue, but we let it be overridden by green for selection clarity
                        if (d_cell.anomaly === 'anomaly' && !isClusterSankeyMatched) {
                            currentFill = anomalyOverrideColor;
                        } else if (activeScale && d_cell.value !== null && typeof d_cell.value === 'number' && isFinite(d_cell.value)) {
                            currentFill = activeScale(d_cell.value); // Use the selected color scale
                        } else {
                            // Background color for empty cells (light green or light blue)
                            currentFill = isClusterSankeyMatched ? customGreensInterpolator(0.05) : customBluesInterpolator(0.01);
                        }

                        cell.attr("data-original-fill", currentFill);

                        // User's direct click on the heatmap (for sidebar) still takes precedence
                        const userClickedHighlightColor = clusterHighlightColors.get(cellClusterIdStr);
                        cell.attr("fill", userClickedHighlightColor ? userClickedHighlightColor : currentFill)
                            .style("stroke", userClickedHighlightColor ? userClickedHighlightColor : defaultStrokeColor)
                            .style("stroke-width", userClickedHighlightColor ? highlightStrokeWidth : defaultStrokeWidth);
                    })
                    .style("cursor", "pointer")
                    .on("click", async function(event, d_click) {
                        event.stopPropagation();
                        const clickedClusterOrGroupID = String(d_click.cluster_id);
                        const isGroupClick = d_click.isGroup;
                        const cellsForClusterOrGroup = heatmapCellGroup.selectAll('.heatmap-cell').filter(cell_d => String(cell_d.cluster_id) === clickedClusterOrGroupID);
                        if (!cellsForClusterOrGroup.empty()) { cellsForClusterOrGroup.raise(); }

                        if (clusterHighlightColors.has(clickedClusterOrGroupID)) {
                            // --- REMOVAL LOGIC ---
                            clusterHighlightColors.delete(clickedClusterOrGroupID);
                            addedSidebarClusters.delete(clickedClusterOrGroupID);
                            cellsForClusterOrGroup.each(function(cell_d) { d3.select(this).transition().duration(100).style('stroke', defaultStrokeColor).style('stroke-width', defaultStrokeWidth); });

                            if (sidebarCy) {
                                let selectorsToRemove = [];
                                if (isGroupClick) {
                                    const groupNode = currentLeaves.find(l_node => String(l_node.data?.cluster_id) === clickedClusterOrGroupID);
                                    const originalLeaves = Array.from(groupNode?.data?.originalLeaves || []);
                                    selectorsToRemove = originalLeaves.map(leafId => `[clusterID = "${leafId}"]`);
                                    
                                    // Also remove original leaves from color map and sidebar tracking set
                                    originalLeaves.forEach(leafId => {
                                        clusterHighlightColors.delete(String(leafId));
                                        addedSidebarClusters.delete(String(leafId));
                                    });

                                } else {
                                    selectorsToRemove.push(`[clusterID = "${clickedClusterOrGroupID}"]`);
                                }
                                if (selectorsToRemove.length > 0) {
                                    const elesToRemove = sidebarCy.elements(selectorsToRemove.join(', '));
                                    if (elesToRemove.length > 0) sidebarCy.remove(elesToRemove);
                                }
                            }
                            if (sidebarCy && sidebarCy.elements().length > 0) {
                                applySidebarSizeControls();
                                updateLegend(sidebarCy.edges());
                                updateSidebarTableForSelectedNodesAndEdges();
                            } else {
                                clearSidebarVisualization();
                                updateLegend();
                            }
                            if (selectedNodeId && (!sidebarCy || !sidebarCy.getElementById(selectedNodeId)?.length)) {
                                deselectCurrentNode();
                                updateSidebarTableForSelectedNodesAndEdges();
                            }
                        } else {
                            // --- ADDITION LOGIC ---
                            if (isGroupClick) {
                                toggleSidebar(true);
                                const groupNode = currentLeaves.find(l_node => String(l_node.data?.cluster_id) === clickedClusterOrGroupID);
                                const originalLeaves = Array.from(groupNode?.data?.originalLeaves || []);
                                
                                if (originalLeaves.length > 0) {
                                    // Assign a color to the GROUP for its heatmap cell highlight
                                    const groupHighlightColor = generateUniqueHighlightColor();
                                    clusterHighlightColors.set(clickedClusterOrGroupID, groupHighlightColor);
                                    cellsForClusterOrGroup.transition().duration(100).style('stroke', groupHighlightColor).style('stroke-width', highlightStrokeWidth);
                                    
                                    // Ensure every ORIGINAL leaf within the group has a unique highlight color
                                    originalLeaves.forEach(originalLeafId => {
                                        const stringLeafId = String(originalLeafId);
                                        if (!clusterHighlightColors.has(stringLeafId)) {
                                            clusterHighlightColors.set(stringLeafId, generateUniqueHighlightColor());
                                        }
                                    });

                                    showSidebarLoading(true, false);
                                    sidebarInfoDiv.innerHTML = `Loading network for Group ${clickedClusterOrGroupID} (${originalLeaves.length} clusters)...`;
                                    sidebarInfoDiv.style.display = 'block';
                                    let allNodesAdded = [], allEdgesAdded = [], errorOccurred = false;

                                    for (const originalLeafId of originalLeaves) {
                                        try {
                                            const response = await fetch(`${API_BASE_URL}/cluster_network?cluster_id=${originalLeafId}`);
                                            if (!response.ok) throw new Error(`Network error (${response.status})`);
                                            const clusterData = await response.json();
                                            let isThisOriginalLeafAnomalous = false;
                                            if (window.fullHeatmapData && window.fullHeatmapData['Count']) {
                                                const metricDataForOriginalLeaf = window.fullHeatmapData['Count'].find(entry => String(entry.cluster) === String(originalLeafId));
                                                if (metricDataForOriginalLeaf && metricDataForOriginalLeaf.clusterAnomaly === 'anomaly') isThisOriginalLeafAnomalous = true;
                                            }
                                            
                                            // Use the specific color for this original leaf
                                            const leafColor = clusterHighlightColors.get(String(originalLeafId)) || '#CCCCCC';

                                            if (clusterData && clusterData.nodes && clusterData.nodes.length > 0) {
                                                const nodesToAdd = clusterData.nodes.map(node_item => ({
                                                    group: 'nodes',
                                                    data: { ...node_item.data, clusterID: originalLeafId, Classification: node_item.data.Classification || 'Unknown' },
                                                    style: { 'background-color': leafColor, ...(isThisOriginalLeafAnomalous && { 'border-color': 'red', 'border-width': 2, 'border-style': 'solid' }) },
                                                    scratch: { _originalColor: leafColor }
                                                }));
                                                allNodesAdded.push(...nodesToAdd);
                                            }
                                            if (clusterData && clusterData.edges) {
                                                const edgesToAdd = clusterData.edges.map(edge => {
                                                    const protocol = edge.data.Protocol || 'Unknown';
                                                    if (!protocolColorMap[protocol]) { let randomColor; do { randomColor = '#' + Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6, '0'); } while (randomColor.toLowerCase() === SELECTED_EDGE_COLOR.toLowerCase()); protocolColorMap[protocol] = randomColor; }
                                                    const edgeColor = protocolColorMap[protocol] || DEFAULT_UNKNOWN_COLOR;
                                                    return { group: 'edges', data: { ...edge.data, clusterID: originalLeafId }, style: { 'line-color': edgeColor, 'target-arrow-color': edgeColor }, scratch: { _protocolColor: edgeColor } };
                                                });
                                                allEdgesAdded.push(...edgesToAdd);
                                            }
                                        } catch (fetchError) { console.error(`Error fetching for ${originalLeafId}:`, fetchError); errorOccurred = true; }
                                    }
                                    showSidebarLoading(false, false);
                                    if (!sidebarCy) { sidebarCy = cytoscape({ container: document.getElementById('sidebar-cy'), style: CYTOSCAPE_STYLE }); bindSidebarGraphEvents(); }
                                    if (allNodesAdded.length > 0 || allEdgesAdded.length > 0) { 
                                        sidebarCy.add(allNodesAdded.concat(allEdgesAdded)); 
                                        addedSidebarClusters.add(clickedClusterOrGroupID);
                                        originalLeaves.forEach(leafId => addedSidebarClusters.add(String(leafId)));
                                        applySidebarSizeControls(); applySidebarLayout(); sidebarCy.fit(null, 30); sidebarInfoDiv.style.display = 'none'; updateLegend(sidebarCy.edges()); loadSidebarClusterTable(originalLeaves[0], 1); 
                                    } 
                                    else if (!errorOccurred) { sidebarInfoDiv.innerHTML = `Group ${clickedClusterOrGroupID}: No network data.`; addedSidebarClusters.add(clickedClusterOrGroupID); loadSidebarClusterTable(originalLeaves[0], 1); } 
                                    else { sidebarInfoDiv.innerHTML = `Group ${clickedClusterOrGroupID}: Some data could not load.`; if (sidebarCy.elements().length > 0) { addedSidebarClusters.add(clickedClusterOrGroupID); originalLeaves.forEach(leafId => addedSidebarClusters.add(String(leafId))); applySidebarSizeControls(); applySidebarLayout(); sidebarCy.fit(null, 30); updateLegend(sidebarCy.edges()); } loadSidebarClusterTable(originalLeaves[0], 1); }
                                    deselectCurrentNode();
                                } else { sidebarInfoDiv.innerHTML = `Group ${clickedClusterOrGroupID}: No underlying clusters.`; showSidebarLoading(false, false); }
                            } else {
                                const targetHighlightColor = generateUniqueHighlightColor();
                                clusterHighlightColors.set(clickedClusterOrGroupID, targetHighlightColor);
                                cellsForClusterOrGroup.transition().duration(100).style('stroke', targetHighlightColor).style('stroke-width', highlightStrokeWidth);
                                const isClusterAnomalous = d_click.anomaly === 'anomaly';
                                visualizeClusterInSidebar(clickedClusterOrGroupID, targetHighlightColor, isClusterAnomalous);
                            }
                        }
                        highlightTreeClusters(new Set(clusterHighlightColors.keys()));
                    })
                    .on("mouseover", function(event, d_mouseover) {
                        const cell = d3.select(this); cell.attr('data-hover-temp-stroke', cell.style('stroke')); cell.attr('data-hover-temp-stroke-width', cell.style('stroke-width')); cell.style("stroke", "black").style("stroke-width", 1.5); 
                        const tooltip = d3.select("#tooltip"); const metricLabel = d_mouseover.feature; const clusterOrGroupId = d_mouseover.cluster_id; const value = d_mouseover.value;
                        const anomalyStatusCell = d_mouseover.anomaly === 'anomaly' ? 'Anomaly Detected' : 'Normal'; const isGroup = d_mouseover.isGroup; const originalCount = d_mouseover.originalLeavesCount;
                        let displayValue = 'N/A'; if (value !== null && typeof value === 'number' && isFinite(value)) { if (metricLabel.includes('%')) displayValue = `${value.toFixed(2)}%`; else if (Number.isInteger(value)) displayValue = value.toLocaleString(); else { const valueStr = String(value); displayValue = (valueStr.includes('e') || valueStr.includes('E')) ? value.toExponential(2) : value.toFixed(3); }}
                        let titleText = isGroup ? `Group: ${clusterOrGroupId} (${originalCount} clusters)` : `Cluster: ${clusterOrGroupId}`;
                        let tooltipHtml = `${titleText}<br>Metric: ${metricLabel}<br>Value: ${displayValue}<br>Status: ${anomalyStatusCell}`;
                        let clusterAttackTypes = []; if (window.fullHeatmapData && window.fullHeatmapData['Count']) { const clusterEntry = window.fullHeatmapData['Count'].find(entry => String(entry.cluster) === String(clusterOrGroupId)); if (clusterEntry && clusterEntry.ClusterAttackTypes && clusterEntry.ClusterAttackTypes.length > 0) clusterAttackTypes = clusterEntry.ClusterAttackTypes; }
                        if (clusterAttackTypes.length > 0) tooltipHtml += `<br><strong style="color:purple;">Cluster Attacks: ${clusterAttackTypes.join(', ')}</strong>`;
                        tooltip.style("display", "block").html(tooltipHtml).style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 15) + "px");
                    })
                    .on("mouseout", function(event, d_mouseout) {
                        d3.select("#tooltip").style("display", "none"); const cell = d3.select(this);
                        const originalStroke = cell.attr('data-hover-temp-stroke'); const originalStrokeWidth = cell.attr('data-hover-temp-stroke-width');
                        if (originalStroke && originalStrokeWidth) { cell.style("stroke", originalStroke).style("stroke-width", originalStrokeWidth); cell.attr('data-hover-temp-stroke', null); cell.attr('data-hover-temp-stroke-width', null); } 
                        else { const cellClusterIdStr = String(d_mouseout.cluster_id); const userClickedHighlightColor = clusterHighlightColors.get(cellClusterIdStr); cell.style("stroke", userClickedHighlightColor ? userClickedHighlightColor : defaultStrokeColor).style("stroke-width", userClickedHighlightColor ? highlightStrokeWidth : defaultStrokeWidth); }
                    });

                cellSelection.filter(d_filter_new => d_filter_new.isNew).each(function(dCell_new) {
                        const cellRect = d3.select(this); const x = parseFloat(cellRect.attr("x")); const y = parseFloat(cellRect.attr("y"));
                        const width = parseFloat(cellRect.attr("width")); const height = parseFloat(cellRect.attr("height"));
                        if (!isNaN(x) && !isNaN(y) && !isNaN(width) && !isNaN(height)) { heatmapLineGroup.append("line").attr("class", "new-cluster-indicator").attr("x1", x).attr("y1", y + height + 1).attr("x2", x + width).attr("y2", y + height + 1).attr("stroke", "red").attr("stroke-width", 1.5).attr("data-cluster-ref", dCell_new.cluster_id); }
                    });

                heatmapLabelGroup.selectAll(".heatmap-feature-label").data(features).join("text").attr("class", "heatmap-feature-label").attr("x", margin.left - 5)
                    .attr("y", d_label => { const yVal = featureScale(d_label); return (typeof yVal === 'number' && isFinite(yVal)) ? yVal + featureScale.bandwidth() / 2 : -1000; })
                    .attr("text-anchor", "end").attr("dominant-baseline", "middle").attr("font-size", "9px").text(d_label => d_label);
                const metricSelectElement = document.getElementById('dendrogramSortMetricSelect');
                const selectedMetricValue = metricSelectElement ? metricSelectElement.value : 'Default';
                const selectedMetricLabelText = metricSelectElement ? metricSelectElement.options[metricSelectElement.selectedIndex].text : null; 
                const featureLabels = heatmapLabelGroup.selectAll(".heatmap-feature-label");
                featureLabels.style("fill", "#333").style("font-weight", "normal"); 
                if (selectedMetricValue !== 'Default' && selectedMetricLabelText) { featureLabels.filter(function(d_filter_label) { return d_filter_label === selectedMetricLabelText; }).style("fill", "#4299e1").style("font-weight", "bold"); }
            } 
        } 

        let dx = 0, dy = 0, initialScale = 1;
        try { 
            const bounds = svgContent.node()?.getBBox(); 
            if (bounds && bounds.width > 0 && bounds.height > 0) {
                const scaleX = viewBoxWidth / bounds.width; const scaleY = viewBoxHeight / bounds.height;
                initialScale = Math.min(scaleX, scaleY) * 0.95; initialScale = Math.max(0.05, Math.min(initialScale, 5)); 
                dx = (viewBoxWidth / 2) - ((bounds.x + bounds.width / 2) * initialScale);
                dy = (viewBoxHeight / 2) - ((bounds.y + bounds.height / 2) * initialScale);
                if(!isFinite(dx)) dx = margin.left; if(!isFinite(dy)) dy = margin.top; if(!isFinite(initialScale) || initialScale <=0) initialScale = 1; 
            } else { 
                dx = margin.left; dy = margin.top; initialScale = 1; 
            }
        } catch(e) { 
            console.error("Error calculating initial zoom transform:", e); dx = margin.left; dy = margin.top; initialScale = 1; 
        }
        initialTreeTransform = d3.zoomIdentity.translate(dx, dy).scale(initialScale);
        const zoomBehavior = d3.zoom().scaleExtent([0.05, 10]) 
            .on("zoom.main", (event) => { 
                svgContent.attr("transform", event.transform); 
                const thresholdSliderElem = document.getElementById('thresholdSlider');
                if (thresholdSliderElem && window.lastTreeRoot && svgContent.node()) { 
                    requestAnimationFrame(() => { thresholdSliderElem.dispatchEvent(new Event('input')); }); 
                } else { 
                    d3.select("#threshold-bar").style("display", "none"); 
                }
            });
        window.inlineZoom = zoomBehavior; 
        svg.call(zoomBehavior).call(zoomBehavior.transform, initialTreeTransform).on("dblclick.zoom", null); 
        if (treeControls) treeControls.style.display = "flex"; 
        try { 
            previousClusterCount = leafCount; 
            previousClusterHash = JSON.stringify(data); 
        } catch(e) { }
        highlightTreeClusters(new Set(clusterHighlightColors.keys()));
        const initialSlider = document.getElementById('thresholdSlider');
        if (initialSlider && window.lastTreeRoot && svgContent.node()) { 
            requestAnimationFrame(() => { initialSlider.dispatchEvent(new Event('input')); }); 
        } else { 
            d3.select("#threshold-bar").style("display", "none"); 
        }
    }

    function resetGroupingAndRedraw() {
        console.log("Resetting grouping...");
        const messageDiv = document.getElementById('reclusterMessage');
        const thresholdSlider = document.getElementById('thresholdSlider');
        const thresholdValueSpan = document.getElementById('thresholdValue');

        if (!window.originalTreeData) { // Check 1: Original data must exist
            console.error("Cannot reset grouping: Original tree data is missing.");
            alert("Error: Cannot reset grouping, original data not found.");
            if (messageDiv) messageDiv.textContent = "Error: Original data missing.";
            return;
        }

        // Restore original data and state
        window.lastTreeData = window.originalTreeData; // CRITICAL: Revert to original
        window.currentGroupingApplied = false;
        window.lastAppliedThreshold = 100;
        
        try {
            // CRITICAL: Recreate the d3 hierarchy object for lastTreeRoot from the original data
            window.lastTreeRoot = d3.hierarchy(window.originalTreeData); 
            console.log("Restored original tree data and reset grouping state. lastTreeRoot updated.");
        } catch (e) {
            console.error("Error creating hierarchy from originalTreeData on reset:", e, window.originalTreeData);
            alert("Error restoring original tree structure.");
            // Attempt to clear or show an error state in the dendrogram if restoration fails
            showInlineDendrogram(null); 
            return;
        }


        if (messageDiv) messageDiv.textContent = '';

        // Redraw the dendrogram with the original data
        // This will also set currentD3LayoutHeight correctly based on the original tree.
        showInlineDendrogram(window.originalTreeData, currentDendrogramHeight); 

        if (thresholdSlider) {
            thresholdSlider.value = 100;
            // The text content will be updated by the dispatched 'input' event.
            requestAnimationFrame(() => {
                // Ensure lastTreeRoot is the one derived from originalTreeData
                if (window.lastTreeRoot && window.lastTreeRoot.data === window.originalTreeData) {
                    thresholdSlider.dispatchEvent(new Event('input'));
                } else {
                    console.warn("Skipping threshold bar update on reset; lastTreeRoot might not be original.")
                }
            });
            console.log("Reset threshold slider visually.");
        }

        clearSidebarVisualization(); // This clears highlights and sidebar graph/table
        updateLegend(); // Reset legend to global state (if applicable)

        updateControlsState(); // Update button states (Reset should become disabled)

        console.log("Grouping reset to the original state.");
    }
    
    function updateControlsState() {
        const groupingApplied = window.currentGroupingApplied || false; // Default to false if undefined

        // Get references to the controls
        const resetGroupingBtn = document.getElementById('resetGroupingBtn');
        const resolutionInput = document.getElementById('resolutionInput');
        const applyResolutionBtn = document.querySelector('#treeControls button[onclick="reclusterAndRedraw()"]'); // Find button by its onclick handler
        const applyThresholdBtn = document.getElementById('applyThresholdBtn'); // Get Apply Threshold button

        // --- Reset Grouping Button ---
        if (resetGroupingBtn) {
            resetGroupingBtn.disabled = !groupingApplied; // ENABLED only if grouping IS applied
            console.log(`Reset Grouping Button disabled: ${!groupingApplied}`);
        } else { console.error("Reset Grouping Button not found in updateControlsState"); }

        // --- Resolution Controls ---
        if (resolutionInput) {
            resolutionInput.disabled = groupingApplied; // Disable Resolution input if grouping IS applied
            console.log(`Resolution Input disabled: ${groupingApplied}`);
        } else { console.error("Resolution Input not found in updateControlsState"); }

        if (applyResolutionBtn) {
            applyResolutionBtn.disabled = groupingApplied; // Disable Apply Resolution button if grouping IS applied
            console.log(`Apply Resolution Button disabled: ${groupingApplied}`);
        } else { console.error("Apply Resolution Button not found in updateControlsState"); }

        // --- Apply Threshold Button ---
        if (applyThresholdBtn) {
             applyThresholdBtn.disabled = false; // Explicitly ensure it's always enabled
             console.log(`Apply Threshold Button disabled: false`); // Log that it's enabled
        } else { console.error("Apply Threshold Button not found in updateControlsState"); }
    }

    function applyThresholdGrouping() {
        console.log("Applying threshold grouping...");
        const thresholdSlider = document.getElementById('thresholdSlider');
        const messageDiv = document.getElementById('reclusterMessage');

        const currentRawData = window.lastTreeData;
        const layoutHeight = window.currentD3LayoutHeight;

        if (!currentRawData) {
            console.error("Cannot apply grouping: Currently displayed tree data (window.lastTreeData) is missing.");
            alert("Error: Cannot apply threshold, current tree data is missing.");
            return;
        }

        if (!layoutHeight || layoutHeight <= 0) {
            console.error("Cannot apply grouping: currentD3LayoutHeight is invalid or not set.", layoutHeight);
            alert("Error: Layout height information is missing or invalid for thresholding. Please ensure the dendrogram is displayed correctly.");
            return;
        }

        if (!thresholdSlider) {
            console.error("Cannot apply grouping: Missing thresholdSlider element.");
            alert("Error: Could not apply threshold grouping. UI element missing.");
            return;
        }

        const physicalValue = parseInt(thresholdSlider.value, 10);
        const currentDisplayMaxBeforeApply = window.lastAppliedThreshold;
        const scaledPercentageToApply = Math.round((physicalValue / 100) * currentDisplayMaxBeforeApply);

        console.log(`Physical slider: ${physicalValue}%, Current Display Max: ${currentDisplayMaxBeforeApply}%, Scaled Pct to Apply: ${scaledPercentageToApply}%`);

        if (scaledPercentageToApply >= currentDisplayMaxBeforeApply && currentDisplayMaxBeforeApply < 100) {
            alert(`To create a new grouping, the threshold (${scaledPercentageToApply}%) must be less than the current displayed maximum of ${currentDisplayMaxBeforeApply}%.`);
            return;
        }
        if (scaledPercentageToApply >= 100) {
            alert("Threshold must be below 100% to apply grouping. To see the full tree, use Reset Grouping.");
            return;
        }

        const thresholdLayoutY = layoutHeight * (scaledPercentageToApply / 100);
        console.log(`Thresholding tree at displayed ${scaledPercentageToApply}%. Effective Layout Y for grouping: ${thresholdLayoutY.toFixed(2)} (based on full Layout Height: ${layoutHeight.toFixed(2)})`);

        let workingRootHierarchy;
        try {
            workingRootHierarchy = d3.hierarchy(structuredClone(currentRawData));
        } catch (e) {
            console.error("Error deep cloning current tree data for grouping:", e);
            alert("Error preparing data for grouping.");
            return;
        }

        const tempTreeLayout = d3.cluster().size([1, layoutHeight]);
        tempTreeLayout(workingRootHierarchy);

        workingRootHierarchy.each(node => {
            node.structuralY = node.y;
            if (typeof node.structuralY !== 'number' || !isFinite(node.structuralY)) {
                node.structuralY = (node.parent && typeof node.parent.structuralY === 'number' && isFinite(node.parent.structuralY))
                                    ? node.parent.structuralY
                                    : 0;
                console.warn(`Fell back to parent's Y or 0 for node:`, node.data.id || node.data.cluster_id);
            }
        });

        const nodesToPrune = new Set();
        const groupRepresentations = new Map();
        let groupingOccurred = false;

        workingRootHierarchy.eachAfter(node => {
            const isBelowThreshold = node.structuralY > thresholdLayoutY + 1e-6;

            if (isBelowThreshold && !nodesToPrune.has(node)) {
                groupingOccurred = true;
                let representativeAncestor = node.parent;
                while (representativeAncestor && (representativeAncestor.structuralY > thresholdLayoutY + 1e-6)) {
                    representativeAncestor = representativeAncestor.parent;
                }
                representativeAncestor = representativeAncestor || node;

                const repAncestorOriginalId = representativeAncestor.data.id || `dist${representativeAncestor.data.dist.toFixed(4)}`;
                const repAncestorDataId = `rep_${repAncestorOriginalId}`;

                if (!groupRepresentations.has(repAncestorDataId)) {
                    const groupId = `GROUP_of_${repAncestorOriginalId}_at_${scaledPercentageToApply}%`; // Use scaledPercentageToApply in ID
                    const groupNodeData = {
                        id: groupId,
                        dist: representativeAncestor.data.dist,
                        isGroup: true,
                        cluster_id: groupId,
                        originalLeaves: new Set(),
                    };
                    groupRepresentations.set(repAncestorDataId, {
                        representativeNodeData: groupNodeData,
                        originalLeavesSet: groupNodeData.originalLeaves
                    });
                }

                const groupInfo = groupRepresentations.get(repAncestorDataId);

                node.leaves().forEach(leafOfCurrentSubtree => {
                    if (leafOfCurrentSubtree.data.isGroup && leafOfCurrentSubtree.data.originalLeaves) {
                        (Array.isArray(leafOfCurrentSubtree.data.originalLeaves) ? leafOfCurrentSubtree.data.originalLeaves : Array.from(leafOfCurrentSubtree.data.originalLeaves)).forEach(originalLeafId => {
                            groupInfo.originalLeavesSet.add(String(originalLeafId));
                        });
                    } else if (leafOfCurrentSubtree.data.cluster_id !== undefined && leafOfCurrentSubtree.data.cluster_id !== null) {
                        groupInfo.originalLeavesSet.add(String(leafOfCurrentSubtree.data.cluster_id));
                    }
                });
                node.descendants().forEach(descendant => nodesToPrune.add(descendant));
            }
        });

        if (!groupingOccurred) {
            alert("No clusters fall below the selected threshold. No grouping applied.");
            if (messageDiv) messageDiv.textContent = "No change: threshold did not cause grouping.";
            if (thresholdSlider) {
                requestAnimationFrame(() => { thresholdSlider.dispatchEvent(new Event('input')); });
            }
            return;
        }

        function buildCompressedTreeData(currentHierarchyNode) {
            if (nodesToPrune.has(currentHierarchyNode)) {
                let representativeAncestor = currentHierarchyNode.parent;
                while (representativeAncestor && (representativeAncestor.structuralY > thresholdLayoutY + 1e-6)) {
                    representativeAncestor = representativeAncestor.parent;
                }
                representativeAncestor = representativeAncestor || currentHierarchyNode;

                const repAncestorOriginalId = representativeAncestor.data.id || `dist${representativeAncestor.data.dist.toFixed(4)}`;
                const repAncestorDataId = `rep_${repAncestorOriginalId}`;

                if (groupRepresentations.has(repAncestorDataId)) {
                    return groupRepresentations.get(repAncestorDataId).representativeNodeData;
                } else {
                    console.error("Critical Error: Pruned node has no group representation during tree build:", currentHierarchyNode.data);
                    return null;
                }
            }

            const newNodeData = { ...currentHierarchyNode.data };
            delete newNodeData.children;

            if (currentHierarchyNode.children && currentHierarchyNode.children.length > 0) {
                const newChildrenList = [];
                currentHierarchyNode.children.forEach(childHierarchyNode => {
                    const newChildData = buildCompressedTreeData(childHierarchyNode);
                    if (newChildData) {
                        if (!newChildrenList.some(existingChild => existingChild.id === newChildData.id)) {
                            newChildrenList.push(newChildData);
                        }
                    }
                });
                if (newChildrenList.length > 0) {
                    newNodeData.children = newChildrenList;
                }
            }
            return newNodeData;
        }

        let compressedTreeData = buildCompressedTreeData(workingRootHierarchy);

        if (!compressedTreeData) {
            console.error("Failed to build compressed tree data. The root itself might have been erroneously pruned or unrepresented.");
            alert("Error: Failed to apply threshold grouping due to an issue in tree reconstruction.");
            return;
        }

        function convertOriginalLeavesSetToArray(node) {
            if (node.isGroup && node.originalLeaves instanceof Set) {
                node.originalLeaves = Array.from(node.originalLeaves);
            }
            if (node.children) {
                node.children.forEach(convertOriginalLeavesSetToArray);
            }
        }
        convertOriginalLeavesSetToArray(compressedTreeData);

        console.log("Compressed tree structure generated:", compressedTreeData);
        window.lastTreeData = compressedTreeData;
        window.currentGroupingApplied = true;
        window.lastAppliedThreshold = scaledPercentageToApply;
        console.log(`Updated window.lastAppliedThreshold to: ${window.lastAppliedThreshold}%`);

        try {
            window.lastTreeRoot = d3.hierarchy(compressedTreeData);
        } catch (e) {
            console.error("Error creating hierarchy from compressed data:", e, compressedTreeData);
            alert("Error finalizing grouped tree structure.");
            return;
        }

        showInlineDendrogram(compressedTreeData, currentDendrogramHeight);

        console.log(`Threshold applied. Clusters below displayed ${scaledPercentageToApply}% merged. Tree and heatmap redrawn.`);
        if (messageDiv) messageDiv.textContent = '';

        clearSidebarVisualization();
        if(isSidebarOpen) toggleSidebar(false);
        updateLegend();

        if (thresholdSlider) {
            thresholdSlider.value = 100; // Set physical slider to max
            requestAnimationFrame(() => { thresholdSlider.dispatchEvent(new Event('input')); });
            console.log("Physical threshold slider reset to 100% position after apply. Displayed text will update.");
        }

        updateControlsState();
    }

    function highlightTreeClusters(selectedClusterIds = new Set()) {
        const svgContent = d3.select("#inlineDendrogramSvg g");
        if (svgContent.empty()) {
            return; // Tree not rendered yet
        }

        const leafNodes = svgContent.selectAll(".node--leaf"); // Select the group containing circle and text
        const leafCircles = leafNodes.select("circle");
        const leafTexts = leafNodes.select("text");
        const defaultTextColor = "#333"; // Default text color

        // Reset all leaves first
        leafCircles.classed("highlighted", false)
                  .transition().duration(150)
                  .attr("r", 4) // Default radius
                  .style("fill", "#999") // Default leaf circle color
                  .style("stroke", "none");

        leafTexts.transition().duration(150)
                .style("fill", defaultTextColor) // Reset text color
                .style("font-weight", "normal"); // Reset font weight

        // Apply highlights based on the provided set and stored colors
        if (selectedClusterIds.size > 0) {
            selectedClusterIds.forEach(clusterId => {
                const stringClusterId = String(clusterId); // Ensure string comparison
                // Get the correct highlight color from the global map
                const highlightColor = clusterHighlightColors.get(stringClusterId);

                if (highlightColor) { // Only highlight if found in the map
                    // Find the matching leaf node(s)
                    const matchedNodes = leafNodes.filter(function(d) {
                        return d && d.data && String(d.data.cluster_id) === stringClusterId;
                    });

                    // Highlight the circle
                    matchedNodes.select("circle")
                        .classed("highlighted", true)
                        .transition().duration(150)
                        .attr("r", 6) // Highlighted radius
                        .style("fill", highlightColor) // Use the specific highlight color from map
                        .style("stroke", "none");

                    // --- Modify Text Color ---
                    try {
                        // Parse the highlight color (assuming HSL format like "hsl(H, S%, L%)")
                        let color = d3.hsl(highlightColor);

                        // Lower saturation (e.g., reduce by 40%, ensure it's between 0 and 1)
                        color.s = Math.max(0, Math.min(1, color.s * 0.6));

                        // Optional: Slightly increase lightness for readability, especially if saturation is low
                        if (color.s < 0.3) {
                            color.l = Math.min(1, color.l + 0.1);
                        }
                        // Ensure lightness isn't too high (avoid white on white)
                        color.l = Math.min(0.85, color.l);

                        const textColor = color.toString(); // Convert back to string

                        // Apply the modified color to the text
                        matchedNodes.select("text")
                            .transition().duration(150)
                            .style("fill", textColor)
                            .style("font-weight", "bold"); // Make text bold for emphasis

                    } catch (e) {
                        console.error("Could not parse highlight color for text:", highlightColor, e);
                        // Fallback: Apply a default highlight color to text if parsing fails
                        matchedNodes.select("text")
                            .transition().duration(150)
                            .style("fill", "#d95f02") // Fallback color (dark orange)
                            .style("font-weight", "bold");
                    }
                    // --- End Text Color Modification ---

                } else {
                    console.warn(`Highlight color not found in map for cluster ${stringClusterId}`);
                }
            });
        }
    }

    function hideDendrogram() {
        const card = document.getElementById('dendrogramCard');
        const showButton = document.getElementById('showTreeBtn');
        card.style.display = 'none';
        showButton.style.display = 'inline-block'; // Show the 'Show Tree' button
        console.log("Dendrogram hidden.");
    }

    function showDendrogram() {
        const card = document.getElementById('dendrogramCard');
        const showButton = document.getElementById('showTreeBtn');
        card.style.display = 'block';    // Show the card
        showButton.style.display = 'none'; // Hide the 'Show Tree' button

        // Optional: Reload or redraw if needed when shown
        if (!window.lastTreeData) {
            console.log("No tree data, loading...");
            loadInlineDendrogram(); // Load data if it wasn't loaded before
        } else {
            console.log("Showing existing dendrogram.");
            // You could potentially redraw or fit view here if desired
            // showInlineDendrogram(window.lastTreeData, document.getElementById("inline-dendrogram-container").clientHeight);
            // resetInlineZoom();
        }
    }
    
    // Optional Helper Function to fit view (Example)
    function fitView() {
        const svg = d3.select("#inlineDendrogramSvg");
        const svgContent = svg.select("g"); // Assumes content is in the first 'g'
        if (!svgContent.empty() && window.inlineZoom) {
            const bounds = svgContent.node().getBBox();
            const parent = svg.node();
            const fullWidth = parent.clientWidth;
            const fullHeight = parent.clientHeight;
            const width = bounds.width;
            const height = bounds.height;
            const midX = bounds.x + width / 2;
            const midY = bounds.y + height / 2;

            if (width === 0 || height === 0) return; // Nothing to fit

            const scale = 0.9 / Math.max(width / fullWidth, height / fullHeight);
            const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];

            svg.transition().duration(750).call(
                window.inlineZoom.transform,
                d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
            );
        }
    }

    function resetInlineZoom() {
        const svg = d3.select("#inlineDendrogramSvg");
        if (window.inlineZoom) {
            // Reset zoom with a smooth transition TO THE STORED INITIAL CENTERED TRANSFORM
            svg.transition().duration(500)
                .call(window.inlineZoom.transform, initialTreeTransform);
            console.log("Inline dendrogram zoom reset to initial view.");
        } else {
            console.warn("Cannot reset zoom, zoom behavior not initialized.");
        }
    }

    function loadInlineDendrogram() {
        console.log("Attempting to load inline dendrogram data...");
        currentNewClusterIds.clear();

        let url = new URL(`${API_BASE_URL}/hierarchical_clusters`);
        
        // Add time selection if it exists
        if (window.currentTimeSelection && window.currentTimeSelection.startTime && window.currentTimeSelection.endTime) {
            url.searchParams.append('start_time', window.currentTimeSelection.startTime.toISOString());
            url.searchParams.append('end_time', window.currentTimeSelection.endTime.toISOString());
        }
        
        // Add resolution if it has a value
        const resolutionInput = document.getElementById('resolutionInput');
        if (resolutionInput && resolutionInput.value) {
            url.searchParams.append('resolution', resolutionInput.value);
        }

        return fetch(url.toString(), { signal: globalAbortController.signal })
            .then(response => {
                if (!response.ok) {
                    return response.json().catch(() => response.text())
                    .then(errBody => {
                        let errMsg = errBody?.error || errBody || `HTTP error ${response.status}`;
                        throw new Error(errMsg);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (globalAbortController.signal.aborted) {
                    console.log("Dendrogram loading aborted before processing data.");
                    throw new DOMException("Operation aborted by user.", "AbortError");
                }
                console.log("Dendrogram data received:", data);
                if (Object.keys(data).length === 0 || (data.error)) {
                    window.originalTreeData = null;
                    window.lastTreeData = null;
                    window.originalLeafCount = 0;
                    showInlineDendrogram(null, undefined, currentNewClusterIds);
                } else {
                    try {
                        window.originalTreeData = structuredClone(data);
                        const originalRoot = d3.hierarchy(window.originalTreeData);
                        window.originalLeafCount = originalRoot.leaves().length;
                    } catch (cloneError) {
                        window.originalTreeData = data;
                        try {
                            const originalRoot = d3.hierarchy(window.originalTreeData);
                            window.originalLeafCount = originalRoot.leaves().length;
                        } catch (countError) {
                            window.originalLeafCount = 0;
                        }
                    }
                    window.currentGroupingApplied = false;
                    window.lastAppliedThreshold = 100;
                    const thresholdSlider = document.getElementById('thresholdSlider');
                    const thresholdValue = document.getElementById('thresholdValue');
                    if(thresholdSlider) thresholdSlider.value = 100;
                    if(thresholdValue) thresholdValue.textContent = '100%';
                    const reclusterMsg = document.getElementById('reclusterMessage');
                    if (reclusterMsg) reclusterMsg.textContent = '';
                    showInlineDendrogram(data, undefined, currentNewClusterIds);
                }
                return Promise.resolve();
            })
            .catch(err => {
                if (err.name === 'AbortError') {
                    console.log("Dendrogram loading was aborted.");
                } else {
                    console.error("Failed to load or render inline dendrogram:", err);
                }
                window.originalTreeData = null;
                window.lastTreeData = null;
                window.originalLeafCount = 0;
                showInlineDendrogram(null, undefined, currentNewClusterIds);
                return Promise.reject(err);
            });
    }

    function formatDuration(seconds) {
        if (seconds === null || seconds === undefined || isNaN(seconds) || seconds < 0) {
            return "N/A";
        }
        if (seconds < 60) {
            return `${seconds.toFixed(2)}s`;
        }
        let minutes = Math.floor(seconds / 60);
        let remainingSeconds = Math.floor(seconds % 60);
        if (minutes < 60) {
            return `${minutes}m ${remainingSeconds}s`;
        }
        let hours = Math.floor(minutes / 60);
        let remainingMinutes = minutes % 60;
        if (hours < 24) {
            return `${hours}h ${remainingMinutes}m ${remainingSeconds}s`;
        }
        let days = Math.floor(hours / 24);
        let remainingHours = hours % 24;
        return `${days}d ${remainingHours}h ${remainingMinutes}m`;
    }

    async function updateTimeInfoDisplay() {
        currentDisplayableTimeInfo = {
            start: "Start: N/A",
            end: "End: N/A",
            duration: "Duration: N/A",
            isSet: false
        };

        try {
            const response = await fetch(`${API_BASE_URL}/time_info`);
            if (!response.ok) {
                let errorMsg = `HTTP error ${response.status}`;
                let errorDetails = "";
                try {
                    const errData = await response.json();
                    errorMsg = errData.error || errorMsg;
                    errorDetails = JSON.stringify(errData);
                } catch (e) {
                    errorDetails = await response.text().catch(() => "Could not retrieve error body.");
                    errorMsg = response.statusText || errorMsg;
                }
                console.error(`updateTimeInfoDisplay: Failed to fetch time info. Status: ${response.status}, Message: ${errorMsg}, Details: ${errorDetails}`);
                return; // Exit if fetch fails
            }
            
            const data = await response.json();

            if (data &&
                typeof data.start_time === 'string' && data.start_time &&
                typeof data.end_time === 'string' && data.end_time &&
                data.duration_seconds !== null && typeof data.duration_seconds !== 'undefined' && !isNaN(parseFloat(data.duration_seconds))) {

                let startTimeStr = "N/A";
                let endTimeStr = "N/A";

                try {
                    const startDate = new Date(data.start_time);
                    if (!isNaN(startDate.getTime())) {
                        startTimeStr = startDate.toLocaleString();
                    } else {
                        startTimeStr = "N/A (bad date)";
                    }
                } catch (e) {
                    startTimeStr = "N/A (parse error)";
                }

                try {
                    const endDate = new Date(data.end_time);
                    if (!isNaN(endDate.getTime())) {
                        endTimeStr = endDate.toLocaleString();
                    } else {
                        endTimeStr = "N/A (bad date)";
                    }
                } catch (e) {
                    endTimeStr = "N/A (parse error)";
                }
                
                const durationFormatted = formatDuration(parseFloat(data.duration_seconds));

                currentDisplayableTimeInfo.start = `Start: ${startTimeStr}`;
                currentDisplayableTimeInfo.end = `End: ${endTimeStr}`;
                currentDisplayableTimeInfo.duration = `Duration: ${durationFormatted}`;
                currentDisplayableTimeInfo.isSet = true;
            }
        } catch (error) {
            console.error('updateTimeInfoDisplay: Exception during fetch or processing time info:', error);
        }
    }

    async function reclusterAndRedraw() {
        const resolutionInput = document.getElementById('resolutionInput');
        const messageDiv = document.getElementById('reclusterMessage');
        const acknowledgeBtn = document.getElementById('acknowledgeNewClustersBtn');
        const treeInfoSpan = document.getElementById('treeInfoSpan');

        let resolution;
        const inputValue = resolutionInput.value.trim();

        if (inputValue === "") {
            resolution = 2.5;
        } else {
            resolution = parseFloat(inputValue);
        }

        if (isNaN(resolution) || resolution <= 0) {
            messageDiv.textContent = "Please enter a valid resolution > 0.";
            messageDiv.style.color = '#e53e3e';
            if (acknowledgeBtn) acknowledgeBtn.style.display = 'none';
            resolutionInput.focus();
            return;
        }

        messageDiv.textContent = "Applying resolution and reclustering...";
        messageDiv.style.color = '#333';
        if (acknowledgeBtn) acknowledgeBtn.style.display = 'none';
        if (treeInfoSpan) treeInfoSpan.textContent = '';
        console.log(`Requesting recluster with resolution: ${resolution}`);
        showLoading();

        previousClusterIdsBeforeRecluster.clear();
        if (window.originalTreeData) {
            try {
                const oldRoot = d3.hierarchy(window.originalTreeData);
                oldRoot.leaves().forEach(leaf => {
                    if (leaf.data && leaf.data.cluster_id !== undefined) {
                        previousClusterIdsBeforeRecluster.add(String(leaf.data.cluster_id));
                    }
                });
            } catch (e) {
                console.warn("Could not get previous cluster IDs from originalTreeData:", e);
            }
        }

        try {
            const response = await fetch(`${API_BASE_URL}/hierarchical_clusters?resolution=${resolution}`, { signal: globalAbortController.signal });
            if (globalAbortController.signal.aborted) {
                console.log("Recluster fetch completed but operation was aborted before processing.");
                throw new DOMException("Operation aborted by user.", "AbortError");
            }
            if (!response.ok) {
                const errBody = await response.json().catch(() => response.text());
                throw new Error(errBody.error || errBody || `HTTP error ${response.status}`);
            }
            const treeData = await response.json();
            console.log("Reclustered tree data received:", treeData);

            if (globalAbortController.signal.aborted) {
                console.log("Reclustering aborted before updating heatmap and dendrogram.");
                throw new DOMException("Operation aborted by user.", "AbortError");
            }

            window.originalTreeData = structuredClone(treeData);
            const newOriginalRoot = d3.hierarchy(window.originalTreeData);
            window.originalLeafCount = newOriginalRoot.leaves().length;

            await updateHeatmap();

            if (globalAbortController.signal.aborted) {
                throw new DOMException("Operation aborted by user.", "AbortError");
            }
            window.currentGroupingApplied = false;
            window.lastAppliedThreshold = 100;
            const thresholdSlider = document.getElementById('thresholdSlider');
            const thresholdValueSpan = document.getElementById('thresholdValue');
            if(thresholdSlider) thresholdSlider.value = 100;
            if(thresholdValueSpan) thresholdValueSpan.textContent = '100%';
            
            updateControlsState();

            const currentClusterIdsFromNewTree = new Set();
            const rootOfNewTree = d3.hierarchy(treeData);
            rootOfNewTree.leaves().forEach(leaf => {
                if (leaf.data && leaf.data.cluster_id !== undefined) {
                    currentClusterIdsFromNewTree.add(String(leaf.data.cluster_id));
                }
            });

            const newIdsForThisOperation = new Set(
                [...currentClusterIdsFromNewTree].filter(id => !previousClusterIdsBeforeRecluster.has(id))
            );
            currentNewClusterIds = newIdsForThisOperation;

            let currentLeafDisplayCount = 0;
            (function countLeaves(node) {
                if (!node || typeof node !== 'object') return;
                if ((!node.children || node.children.length === 0) && node.id !== "empty_root" && node.id !== "empty_root_no_data" && node.id !== "error_root" && node.id !== "error_scipy_tree" ) {
                    if(node.cluster_id !== undefined && node.cluster_id !== null) currentLeafDisplayCount++;
                } else if (node.children) {
                    node.children.forEach(countLeaves);
                }
            })(treeData);
            
            if (currentNewClusterIds.size > 0) {
                messageDiv.textContent = `Reclustering complete. ${currentLeafDisplayCount} leaf clusters found (${currentNewClusterIds.size} new).`;
                messageDiv.style.color = '#e53e3e';
                if (acknowledgeBtn) acknowledgeBtn.style.display = 'inline-block';
            } else if (previousClusterIdsBeforeRecluster.size > 0 && currentClusterIdsFromNewTree.size !== previousClusterIdsBeforeRecluster.size) {
                messageDiv.textContent = `Reclustering complete. ${currentLeafDisplayCount} leaf clusters found. Structure changed.`;
                messageDiv.style.color = '#333';
                if (acknowledgeBtn) acknowledgeBtn.style.display = 'none';
            }
            else {
                messageDiv.textContent = `Reclustering complete. ${currentLeafDisplayCount} leaf clusters found. No new clusters identified.`;
                messageDiv.style.color = '#333';
                if (acknowledgeBtn) acknowledgeBtn.style.display = 'none';
            }

            showInlineDendrogram(treeData, currentDendrogramHeight, currentNewClusterIds);
            resetInlineZoom();
            updateLegend();
            clearSidebarVisualization();

            const thresholdSliderElem = document.getElementById('thresholdSlider');
            if (thresholdSliderElem && window.lastTreeRoot) {
                requestAnimationFrame(() => { thresholdSliderElem.dispatchEvent(new Event('input')); });
            }

        } catch (err) {
            if (err.name === 'AbortError') {
                console.log("Recluster and redraw operation aborted.");
            } else {
                console.error("Error during recluster/redraw:", err);
                messageDiv.textContent = `Error: ${err.message || "Failed to recluster."}`;
                messageDiv.style.color = '#e53e3e';
                if (acknowledgeBtn) acknowledgeBtn.style.display = 'none';
                if (treeInfoSpan) treeInfoSpan.textContent = '';
                window.originalTreeData = null;
                window.lastTreeData = null;
                window.originalLeafCount = 0;
                currentNewClusterIds.clear();
                showInlineDendrogram(null, currentDendrogramHeight, currentNewClusterIds);
            }
        } finally {
            if (!globalAbortController.signal.aborted) {
                hideLoading();
            }
        }
    }

    // Function to add an item to the saved list
    function addSavedItem(item) { 
        if (savedItems.some(saved => saved.id === item.id && saved.type === item.type)) {
            console.log("Item already saved:", item);
            return;
        }
        if (savedItems.length >= MAX_SAVED_ITEMS) {
            alert(`You can save a maximum of ${MAX_SAVED_ITEMS} items. Please remove an item to save a new one.`);
            return;
        }
        savedItems.push(item);
        renderSavedItemsList();
        console.log("Saved item:", item);
    }

    // Function to remove an item from the saved list
    function removeSavedItem(itemId) {
        savedItems = savedItems.filter(item => item.id !== itemId);
        renderSavedItemsList();
        console.log("Removed item with ID:", itemId);
    }

    function handleSaveSelection() {
        if (!isSidebarOpen || !sidebarCy) {
            alert("Please open the sidebar and ensure a visualization is active.");
            return;
        }

        if (selectedSidebarNodes.size === 0) {
            alert("Please select at least one node to save its cluster information.");
            return;
        }

        const nodesByCluster = new Map();

        // Group selected nodes by their clusterID and collect details
        selectedSidebarNodes.forEach(nodeId => {
            const node = sidebarCy.getElementById(nodeId);
            if (node && node.length > 0) {
                const nodeData = node.data();
                const clusterID = String(nodeData.clusterID);
                const ipAddress = node.id(); // Assuming node ID is the IP address
                const attackTypes = nodeData.InvolvedAttackTypes || []; // Get from node data

                if (!nodesByCluster.has(clusterID)) {
                    nodesByCluster.set(clusterID, []);
                }
                nodesByCluster.get(clusterID).push({
                    ip: ipAddress,
                    attackTypes: attackTypes
                });
            }
        });

        if (nodesByCluster.size === 0) {
            alert("Could not retrieve details for selected nodes.");
            return;
        }

        let itemsProcessedCount = 0; // To track if anything was saved or updated

        nodesByCluster.forEach((newlySelectedNodeDetailsList, clusterID) => {
            const existingSavedItemIndex = savedItems.findIndex(item => item.id === clusterID && item.type === 'cluster-with-details');

            if (existingSavedItemIndex !== -1) {
                // --- ITEM EXISTS, UPDATE IT ---
                const existingItem = savedItems[existingSavedItemIndex];
                let updated = false;

                newlySelectedNodeDetailsList.forEach(newNodeDetail => {
                    // Check if this specific node (by IP) is already in the saved details for this cluster
                    const alreadySelected = existingItem.data.selectedNodesDetails.some(existingNode => existingNode.ip === newNodeDetail.ip);
                    if (!alreadySelected) {
                        existingItem.data.selectedNodesDetails.push(newNodeDetail);
                        updated = true;
                    }
                });

                if (updated) {
                    // Rebuild displayDescriptions based on the potentially updated selectedNodesDetails
                    existingItem.data.displayDescriptions = existingItem.data.selectedNodesDetails.map(detail => {
                        let desc = `IP: ${detail.ip}`;
                        if (detail.attackTypes && detail.attackTypes.length > 0 && detail.attackTypes.join('') !== "N/A") {
                            desc += ` (Attacks: ${detail.attackTypes.join(', ')})`;
                        }
                        return desc;
                    });
                    console.log(`Updated existing saved item for Cluster ${clusterID}:`, existingItem);
                    itemsProcessedCount++;
                } else {
                    console.log(`No new nodes to add to existing saved item for Cluster ${clusterID}. All selected nodes were already present.`);
                }

            } else {
                // --- ITEM DOES NOT EXIST, ADD NEW ---
                if (savedItems.length >= MAX_SAVED_ITEMS) {
                    alert(`Cannot save Cluster ${clusterID}. Maximum of ${MAX_SAVED_ITEMS} items reached. Please remove an item to save a new one.`);
                    return; // Skip processing this cluster if max is reached
                }

                const displayDescriptions = newlySelectedNodeDetailsList.map(detail => {
                    let desc = `IP: ${detail.ip}`;
                    if (detail.attackTypes && detail.attackTypes.length > 0 && detail.attackTypes.join('') !== "N/A") {
                        desc += ` (Attacks: ${detail.attackTypes.join(', ')})`;
                    }
                    return desc;
                });

                const newItem = {
                    id: clusterID, // Use clusterID as the unique ID for this saved item
                    type: 'cluster-with-details', // New type
                    name: `Cluster ${clusterID}`,
                    data: {
                        clusterId: clusterID,
                        // Store the original selected IPs and their full descriptions for display
                        selectedNodesDetails: newlySelectedNodeDetailsList, // This is a fresh list for a new item
                        displayDescriptions: displayDescriptions // For easy rendering in the list
                    }
                };
                savedItems.push(newItem); // Directly add the new item to the list
                console.log(`Added new saved item for Cluster ${clusterID}:`, newItem);
                itemsProcessedCount++;
            }
        });

        if (itemsProcessedCount > 0) {
            renderSavedItemsList(); // Re-render the list if any item was added or updated
            console.log(`${itemsProcessedCount} cluster(s)/group(s) processed (saved or updated) with node details.`);

            // Clear current node selections after saving
            if (sidebarCy) {
                sidebarCy.nodes().filter(n => selectedSidebarNodes.has(n.id())).unselect().forEach(n => {
                    const originalNodeColor = n.scratch('_originalColor') || clusterHighlightColors.get(String(n.data('clusterID'))) || '#888';
                    n.style('background-color', originalNodeColor);
                });
            }
            selectedSidebarNodes.clear();
            updateSidebarTableForSelectedNodesAndEdges(); // Revert table to broader context if needed
        } else {
            // This case can occur if the save limit was hit before processing any cluster,
            // or if all selected nodes were already present in existing saved items and no new items could be added.
            alert("No new information was saved. Selected nodes might already be part of saved items, or the save limit was reached for new entries.");
        }
    }

    async function fetchAndRenderLouvainIpGraph() {
        const graphLoadingIndicator = document.getElementById('packetSimilarityLoading');
        const graphContainerDiv = document.getElementById('louvain-ip-graph-container');
        const ipGraphLayoutSelect = document.getElementById('ipGraphLayoutSelect');

        if (!graphLoadingIndicator || !graphContainerDiv) {
            console.error("Required HTML elements for IP graph are missing.");
            return;
        }

        showLoading();
        graphLoadingIndicator.style.display = 'flex';

        if (window.louvainIpCy) {
            window.louvainIpCy.destroy();
            window.louvainIpCy = null;
        }
        graphContainerDiv.innerHTML = '';

        try {
            const response = await fetch(`${API_BASE_URL}/louvain_ip_graph_data`, { signal: globalAbortController.signal });

            if (globalAbortController.signal.aborted) {
                throw new DOMException("Operation aborted by user.", "AbortError");
            }

            if (!response.ok) {
                const errData = await response.json().catch(() => ({ error: "Failed to fetch Louvain IP graph data." }));
                throw new Error(errData.error || `HTTP error ${response.status}`);
            }
            const graphData = await response.json();

            if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
                graphContainerDiv.innerHTML = '<p style="text-align:center; padding-top:50px;">No IP graph data to display.</p>';
                return;
            }
            
            window.louvainIpCy = cytoscape({
                container: graphContainerDiv,
                elements: {
                    nodes: graphData.nodes,
                    edges: graphData.edges
                },
                style: [ // Using the simplified style from the previous step
                    {
                        selector: 'node',
                        style: {
                            'background-color': 'data(node_color)', 
                            'width': 25, 
                            'height': 25, 
                            'shape': 'ellipse'
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'line-color': '#888', 
                            'width': 2
                        }
                    }
                ],
                layout: {
                    name: 'preset',
                    fit: true,
                    padding: 50,
                    animate: false
                },
                minZoom: 0.05,
                maxZoom: 5,
                wheelSensitivity: 0.2,
                autoungrabify: true, 
            });
            
            window.louvainIpCy.fit(undefined, 50);

            const tooltip = d3.select("#tooltip");

            window.louvainIpCy.removeListener('mouseover mouseout click'); 

            window.louvainIpCy.on('mouseover', 'node', (event) => {
                const el = event.target;
                const data = el.data();

                let content = `<b>IP:</b> ${data.label || data.id}`; 
                if (data.is_attacker) {
                    content += ` <strong style="color:#FF3333;">(Attacker)</strong>`;
                }
                content += `<br><b>Community:</b> ${data.clusterId || 'N/A'}`;
                if (data.is_community_anomalous && !data.is_attacker) {
                    content += ` <strong style="color:orange;">(In Anomalous Community)</strong>`;
                }
                content += `<br><b>Class:</b> ${data.classification || 'N/A'}`;
                content += `<br><b>Total Pkts (Graph):</b> ${data.packet_count || 0}`;

                if (data.features_for_pca) {
                    content += `<br>--- PCA Input Features ---`;
                    content += `<br>Outgoing Pkts: ${data.features_for_pca.outgoing_packets}`;
                    content += `<br>Incoming Pkts: ${data.features_for_pca.incoming_packets}`;
                    content += `<br>Outgoing Bytes: ${data.features_for_pca.outgoing_bytes}`;
                    content += `<br>Incoming Bytes: ${data.features_for_pca.incoming_bytes}`;
                    content += `<br>Distinct Dests: ${data.features_for_pca.distinct_destinations}`;
                    content += `<br>Distinct Srcs (contacted by): ${data.features_for_pca.distinct_sources_contacted_by}`;
                    content += `<br>Src Sessions: ${data.features_for_pca.source_sessions}`;
                    content += `<br>Dest Sessions: ${data.features_for_pca.destination_sessions}`;
                }
                
                if (content && event.originalEvent) { 
                    tooltip.html(content).style("display", "block")
                        .style("left", (event.originalEvent.pageX + 10) + "px")
                        .style("top", (event.originalEvent.pageY - 15) + "px");
                } else if (content && event.renderedPosition) { 
                     const graphContainerRect = graphContainerDiv.getBoundingClientRect();
                     tooltip.html(content).style("display", "block")
                        .style("left", (graphContainerRect.left + event.renderedPosition.x + window.scrollX + 10) + "px")
                        .style("top", (graphContainerRect.top + event.renderedPosition.y + window.scrollY - 15) + "px");
                } else {
                    tooltip.style("display", "none");
                }
            });
            
            window.louvainIpCy.on('mouseover', 'edge', (event) => {
                const el = event.target;
                const data = el.data();
                let content = `<b>Source:</b> ${data.source}`;
                content += `<br><b>Target:</b> ${data.target}`;
                content += `<br><b>Packets:</b> ${data.packet_count || 0}`;
                content += `<br><b>Total Bytes:</b> ${data.total_length || 0}`;
                 if (content && event.originalEvent) { 
                    tooltip.html(content).style("display", "block")
                        .style("left", (event.originalEvent.pageX + 10) + "px")
                        .style("top", (event.originalEvent.pageY - 15) + "px");
                } else if (content && event.renderedPosition) {
                     const graphContainerRect = graphContainerDiv.getBoundingClientRect();
                     tooltip.html(content).style("display", "block")
                        .style("left", (graphContainerRect.left + event.renderedPosition.x + window.scrollX + 10) + "px")
                        .style("top", (graphContainerRect.top + event.renderedPosition.y + window.scrollY - 15) + "px");
                } else {
                    tooltip.style("display", "none");
                }
            });

            window.louvainIpCy.on('mouseout', 'node, edge', (event) => { 
                tooltip.style("display", "none");
            });

            window.louvainIpCy.on('click', 'node', function(event) {
                const node = event.target;
                if (window.sidebarCy) {
                    const sidebarNode = window.sidebarCy.getElementById(node.id());
                    if (sidebarNode.length > 0) {
                        toggleSidebar(true);
                        sidebarNode.trigger('click');
                        window.sidebarCy.animate({ fit: { eles: sidebarNode, padding: 100 } }, { duration: 400 });
                    } else {
                        const clusterToLoad = node.data('clusterId');
                        if (clusterToLoad && clusterToLoad !== 'N/A') {
                            let highlightColor = clusterHighlightColors.get(clusterToLoad);
                            if (!highlightColor) {
                                highlightColor = generateUniqueHighlightColor();
                                clusterHighlightColors.set(clusterToLoad, highlightColor);
                            }
                            const isAnomalousCommunity = node.data('is_community_anomalous') || false;
                            visualizeClusterInSidebar(clusterToLoad, highlightColor, isAnomalousCommunity)
                                .then(() => {
                                    const newlyAddedNodeInSidebar = window.sidebarCy.getElementById(node.id());
                                    if(newlyAddedNodeInSidebar && newlyAddedNodeInSidebar.length > 0){
                                       newlyAddedNodeInSidebar.trigger('click');
                                       window.sidebarCy.animate({ fit: { eles: newlyAddedNodeInSidebar, padding: 100 } }, { duration: 400 });
                                    }
                                });
                            highlightTreeClusters(new Set(clusterHighlightColors.keys()));
                        }
                    }
                }
            });
            if (ipGraphLayoutSelect && ipGraphLayoutSelect.value !== 'preset') {
                ipGraphLayoutSelect.value = 'preset';
            }

        } catch (error) {
            if (error.name === 'AbortError') {
                console.log("Louvain IP graph loading aborted by user.");
                graphContainerDiv.innerHTML = `<p style="text-align:center; padding-top:50px;">Operation Cancelled by user.</p>`;
            } else {
                console.error("Error fetching/rendering Louvain IP graph:", error);
                graphContainerDiv.innerHTML = `<p style="text-align:center; padding-top:50px;">Error loading IP Graph: ${error.message}</p>`;
            }
        } finally {
            graphLoadingIndicator.style.display = 'none';
            if (!globalAbortController.signal.aborted) {
                hideLoading();
            }
        }
    }

    async function fetchAndRenderSankeyDiagram() {
        const sankeyContainer = d3.select("#sankey-diagram-container");
        const loadingIndicator = document.getElementById('sankeyLoading');

        if (!sankeyContainer.node()) {
            console.error("Sankey container not found.");
            if(loadingIndicator) loadingIndicator.style.display = 'none'; // Ensure loading is hidden
            return;
        }
        sankeyContainer.html(""); 
        if(loadingIndicator) loadingIndicator.style.display = 'flex';
        sankeyDiagramRendered = false;

        let activeDimensions = []; 
        window.currentSankeyDimensionsOrder.forEach(dimDefinition => {
            const checkbox = document.getElementById(`sankey_dim_cb_${dimDefinition.value}`);
            if (checkbox && checkbox.checked) {
                activeDimensions.push(dimDefinition.value); 
            }
        });

        if (activeDimensions.length < 2) {
            alert("Please select at least two dimensions for the Sankey diagram.");
            if(loadingIndicator) loadingIndicator.style.display = 'none';
            sankeyContainer.html("<p style='color:red; text-align:center; padding-top: 50px;'>Error: Please select at least two dimensions.</p>");
            return;
        }
        
        try {
            const response = await fetch(`${API_BASE_URL}/sankey_data?dimensions=${activeDimensions.join(',')}`);
            if (!response.ok) {
                const errData = await response.json().catch(() => ({error: `HTTP error ${response.status}`}));
                throw new Error(errData.error || `Failed to fetch Sankey data.`);
            }
            const data = await response.json();

            if (data.error) {
                throw new Error(data.error);
            }
            if (!data.nodes || data.nodes.length === 0 || !data.links || data.links.length === 0) {
                sankeyContainer.html("<p style='text-align:center; padding-top:50px;'>No data available for the selected Sankey dimensions.</p>");
                sankeyDiagramRendered = false; 
                if(loadingIndicator) loadingIndicator.style.display = 'none';
                return;
            }

            renderSankey(data, "#sankey-diagram-container", activeDimensions); 
            sankeyDiagramRendered = true;

        } catch (error) {
            console.error("Error fetching or rendering Sankey diagram:", error);
            sankeyContainer.html(`<p style='color:red; text-align:center; padding-top: 50px;'>Error: ${error.message}</p>`);
            sankeyDiagramRendered = false;
        } finally {
            if(loadingIndicator) loadingIndicator.style.display = 'none';
        }
    }

    function renderSankey(data, containerSelector, activeDimensions) {
        const container = d3.select(containerSelector);
        const containerNode = container.node();
        if (!containerNode) {
            console.error("Sankey container node not found in renderSankey.");
            return;
        }
        container.selectAll("svg").remove();

        const containerRect = containerNode.getBoundingClientRect();
        const margin = {top: 30, right: 200, bottom: 30, left: 200};

        const svgWidth = containerRect.width > 0 ? containerRect.width : 800;
        const svgHeight = containerRect.height > 0 ? containerRect.height : 700;

        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;

        if (width <= 0 || height <= 0) {
            container.html("<p style='text-align:center; color:orange; padding-top:50px;'>Cannot render Sankey: container too small or not visible.</p>");
            return;
        }

        const svg = container.append("svg")
            .attr("width", svgWidth)
            .attr("height", svgHeight)
            .style("font", "10px sans-serif")
        .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        let focusedNode = null;
        const highlightedLinks = new Set();
        const highlightedNodes = new Set();
        const applySankeyBtn = document.getElementById('applySankeyToHeatmapBtn');

        function clearFocusHighlight() {
            focusedNode = null;
            highlightedLinks.clear();
            highlightedNodes.clear();

            // Reset link opacity
            svg.selectAll(".link-group path").transition().duration(250).attr("stroke-opacity", 0.4);

            // Animate all foreground rectangles back to full height
            svg.selectAll(".node-rect-highlighted")
                .transition().duration(250)
                .attr("height", d => Math.max(1, d.y1 - d.y0));

            console.log("Sankey visual focus cleared (split-node).");
        }

        function applyFocusHighlight() {
            const linkHighlightOpacity = 0.7;
            const linkDimOpacity = 0.1;

            // Highlight links on the path and dim others (binary).
            svg.selectAll(".link-group path")
                .transition().duration(300)
                .attr("stroke-opacity", d => highlightedLinks.has(d) ? linkHighlightOpacity : linkDimOpacity);

            // For each node, calculate the proportion of its total flow that is part of the highlighted path.
            nodes.forEach(node => {
                const totalNodeValue = node.value;
                if (totalNodeValue === 0) {
                    node.highlightRatio = 0;
                    return;
                }
                const highlightedIncomingValue = d3.sum(node.targetLinks, l => highlightedLinks.has(l) ? l.value : 0);
                const highlightedOutgoingValue = d3.sum(node.sourceLinks, l => highlightedLinks.has(l) ? l.value : 0);
                const highlightedFlowValue = Math.max(highlightedIncomingValue, highlightedOutgoingValue);
                node.highlightRatio = highlightedFlowValue / totalNodeValue;
            });

            // Animate the height of the foreground rectangle based on the calculated ratio.
            svg.selectAll(".node-rect-highlighted")
                .transition().duration(350)
                .attr("height", d => {
                    const fullHeight = Math.max(1, d.y1 - d.y0);
                    // For the selected node, the height is always 100%
                    if (d === focusedNode) {
                        return fullHeight;
                    }
                    return fullHeight * (d.highlightRatio || 0);
                });

            console.log("Sankey split-node focus applied.");
        }

        svg.on("click", function(event) {
            if (event.target === this && focusedNode) {
                clearFocusHighlight();
                window.activeSankeyNodeFilter = null;
                window.sankeyMatchingClusterIds.clear();
                if (applySankeyBtn) {
                    applySankeyBtn.disabled = true;
                    applySankeyBtn.style.backgroundColor = "#6c757d";
                }
                updateMainViewAfterSankeyFilter();
            }
        });

        const sankeyLayout = d3.sankey()
            .nodeId(d_node => d_node.node)
            .nodeAlign(d3.sankeyJustify)
            .nodeWidth(20).nodePadding(12)
            .extent([[1, 5], [width - 1, height - 5]]);

        const {nodes, links} = sankeyLayout(data);
        const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
        nodes.forEach(node => { node.color = colorScale(node.name.split(":")[0]); });

        const linkGroups = svg.append("g").attr("fill", "none").attr("stroke-opacity", 0.4)
            .selectAll("g.link-group").data(links).join("g")
            .attr("class", "link-group").style("mix-blend-mode", "multiply");

        linkGroups.append("path")
            .attr("d", d3.sankeyLinkHorizontal())
            .attr("stroke", d_link => d_link.source.color || d_link.target.color || "#777")
            .attr("stroke-width", d_link => Math.max(1.5, d_link.width))
            .on("mouseover", function(event, d_link_hovered) {
                d3.select(this).attr("stroke-opacity", 0.7);
                tooltip.style("display", "block")
                    .html(`<strong>${d_link_hovered.source.name}</strong> &rarr; <strong>${d_link_hovered.target.name}</strong><br>Value: ${d_link_hovered.value.toLocaleString()}`)
                    .style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 15) + "px");
            })
            .on("mouseout", function(event, d_link_hovered) {
                if (!focusedNode || highlightedLinks.has(d_link_hovered)) {
                   d3.select(this).attr("stroke-opacity", focusedNode ? 0.7 : 0.4);
                } else {
                   d3.select(this).attr("stroke-opacity", 0.1);
                }
                tooltip.style("display", "none");
            })
            .append("title").text(d_title => `${d_title.source.name} \u2192 ${d_title.target.name}\nValue: ${d_title.value.toLocaleString()}`);

        const nodeGroup = svg.append("g").selectAll("g.node-group").data(nodes).join("g")
            .attr("class", "node-group")
            .attr("transform", d_node => `translate(${d_node.x0}, ${d_node.y0})`)
            .on("click", function(event, d_node_clicked) {
                event.stopPropagation();
                if (focusedNode === d_node_clicked) {
                    clearFocusHighlight();
                } else {
                    focusedNode = d_node_clicked;
                    const pathNodes = new Set([focusedNode]);
                    highlightedLinks.clear();
                    let fwdQueue = [focusedNode];
                    while (fwdQueue.length > 0) {
                        const curr = fwdQueue.shift();
                        (curr.sourceLinks || []).forEach(l => { highlightedLinks.add(l); if (!pathNodes.has(l.target)) { pathNodes.add(l.target); fwdQueue.push(l.target); } });
                    }
                    let bwdQueue = [focusedNode];
                    while (bwdQueue.length > 0) {
                        const curr = bwdQueue.shift();
                        (curr.targetLinks || []).forEach(l => { highlightedLinks.add(l); if (!pathNodes.has(l.source)) { pathNodes.add(l.source); bwdQueue.push(l.source); } });
                    }
                    highlightedNodes.clear();
                    pathNodes.forEach(n => highlightedNodes.add(n));
                    applyFocusHighlight();
                }
            });

        // Background rectangle for the "dimmed" portion (always gray).
        nodeGroup.append("rect")
            .attr("class", "node-rect-dimmed")
            .attr("height", d => Math.max(1, d.y1 - d.y0))
            .attr("width", d => d.x1 - d.x0)
            .attr("fill", "#e0e0e0")
            .attr("stroke", "#bbb")
            .attr("stroke-width", 0.5);

        // Foreground rectangle for the "highlighted" portion (colored).
        nodeGroup.append("rect")
            .attr("class", "node-rect-highlighted")
            .attr("height", d => Math.max(1, d.y1 - d.y0)) // Initially full height.
            .attr("width", d => d.x1 - d.x0)
            .attr("fill", d => d.color)
            .append("title").text(d_title => `${d_title.name}\nTotal Value: ${d_title.value.toLocaleString()}`);

        nodeGroup.append("text")
            .attr("x", d_node => d_node.x0 < width / 2 ? (d_node.x1 - d_node.x0 + 8) : -8)
            .attr("y", d_node => (d_node.y1 - d_node.y0) / 2)
            .attr("dy", "0.35em").attr("text-anchor", d_node => d_node.x0 < width / 2 ? "start" : "end")
            .style("font-size", "11px").style("fill", "#000").style("pointer-events", "none")
            .text(d_node => { const MAX_LABEL_LENGTH = 30; return d_node.name.length > MAX_LABEL_LENGTH ? d_node.name.substring(0, MAX_LABEL_LENGTH - 3) + "..." : d_node.name; });
    }

    async function updateMainViewAfterSankeyFilter() {
        console.log("Updating main view due to Sankey filter change. Current filter:", window.activeSankeyNodeFilter);
        showLoading();
        try {
            window.sankeyMatchingClusterIds.clear(); // Clear previous matches

            if (window.activeSankeyNodeFilter) {
                console.log("Active Sankey filter detected, fetching matching cluster IDs...");
                const mainFilters = {
                    payloadKeyword: document.getElementById('payloadSearch').value.trim().toLowerCase(),
                    sourceFilter: document.getElementById('sourceFilter').value.trim().toLowerCase(),
                    destinationFilter: document.getElementById('destinationFilter').value.trim().toLowerCase(),
                    protocolFilter: document.getElementById('protocolFilter').value.trim().toLowerCase(),
                    minSourceAmt: document.getElementById('minSourceAmtFilter').value,
                    maxSourceAmt: document.getElementById('maxSourceAmtFilter').value,
                    minDestinationAmt: document.getElementById('minDestinationAmtFilter').value,
                    maxDestinationAmt: document.getElementById('maxDestinationAmtFilter').value
                };

                const response = await fetch(`${API_BASE_URL}/get_sankey_matching_clusters`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sankeyFilter: window.activeSankeyNodeFilter,
                        mainFilters: mainFilters
                    }),
                    signal: globalAbortController.signal 
                });

                if (globalAbortController.signal.aborted) {
                    throw new DOMException("Operation aborted by user.", "AbortError");
                }
                if (!response.ok) {
                    const errData = await response.json().catch(() => ({error: `HTTP error ${response.status}`}));
                    throw new Error(errData.error || `Failed to fetch Sankey matching clusters.`);
                }
                const data = await response.json();
                if (data.matchingClusterIds) {
                    window.sankeyMatchingClusterIds = new Set(data.matchingClusterIds.map(String));
                    console.log("Sankey matching cluster IDs fetched:", Array.from(window.sankeyMatchingClusterIds));
                }
            } else {
                console.log("Sankey filter is null, sankeyMatchingClusterIds cleared.");
            }
            
            if (window.lastTreeData) {
                showInlineDendrogram(window.lastTreeData, document.getElementById("inline-dendrogram-container").clientHeight, currentNewClusterIds);
            } else {
                // Fallback to a full load if for some reason there's no data to draw.
                console.warn("No tree data available. Performing a full load.");
                await updateHeatmap();
                await loadInlineDendrogram();
            }

        } catch (error) {
            if (error.name === 'AbortError') {
                console.log("Main view update after Sankey filter aborted by user.");
            } else {
                console.error("Error updating main view after Sankey filter:", error);
                alert(`Error applying Sankey filter to main view: ${error.message || 'Unknown error'}`);
            }
        } finally {
            if (!globalAbortController.signal.aborted) {
                hideLoading();
            }
        }
    }

    function moveSankeyDimension(index, direction) {
        if (direction === 'left' && index > 0) {
            // Swap with previous element
            [window.currentSankeyDimensionsOrder[index], window.currentSankeyDimensionsOrder[index - 1]] = 
            [window.currentSankeyDimensionsOrder[index - 1], window.currentSankeyDimensionsOrder[index]];
        } else if (direction === 'right' && index < window.currentSankeyDimensionsOrder.length - 1) {
            // Swap with next element
            [window.currentSankeyDimensionsOrder[index], window.currentSankeyDimensionsOrder[index + 1]] = 
            [window.currentSankeyDimensionsOrder[index + 1], window.currentSankeyDimensionsOrder[index]];
        }

        populateSankeyDimensionCheckboxes(); // Re-render the checkboxes with new order and button states

        const sankeyCard = document.getElementById('sankeyCard');
        if (sankeyCard && sankeyCard.style.display !== 'none' && sankeyCard.style.display !== '') {
            fetchAndRenderSankeyDiagram(); // Update Sankey diagram if it's visible
        }
    }

    function populateSankeyDimensionCheckboxes() {
        const container = document.getElementById('sankeyDimensionCheckboxes');
        if (!container) {
            console.error("Sankey dimension checkbox container not found.");
            return;
        }
        container.innerHTML = ''; // Clear existing

        window.currentSankeyDimensionsOrder.forEach((dim, index) => {
            const div = document.createElement('div');
            // This is the container for ONE filter option (checkbox, label, buttons)
            div.style.display = 'flex';
            div.style.alignItems = 'center';
            div.style.marginBottom = '5px';
            div.style.padding = '3px 6px'; // A little padding
            div.style.border = '1px solid #ddd'; // Border to group elements together visually
            div.style.borderRadius = '5px';
            div.style.marginRight = '8px'; // Spacing between filter groups

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `sankey_dim_cb_${dim.value}`;
            checkbox.value = dim.value;
            checkbox.checked = dim.defaultChecked;
            checkbox.setAttribute('data-label', dim.label);
            checkbox.style.marginRight = '5px';

            checkbox.addEventListener('change', () => {
                const dimInOrder = window.currentSankeyDimensionsOrder.find(d => d.value === checkbox.value);
                if (dimInOrder) {
                    dimInOrder.defaultChecked = checkbox.checked;
                }
                const sankeyCard = document.getElementById('sankeyCard');
                if (sankeyCard && sankeyCard.style.display !== 'none' && sankeyCard.style.display !== '') {
                    fetchAndRenderSankeyDiagram();
                }
            });

            const label = document.createElement('label');
            label.htmlFor = checkbox.id;
            label.textContent = dim.label;
            label.style.marginRight = '5px'; // Reduced margin
            label.style.minWidth = '110px'; 
            label.style.marginBottom = '0'; // Remove bottom margin from label

            const leftBtn = document.createElement('button');
            leftBtn.innerHTML = '&#x25C0;'; // Left arrow
            leftBtn.title = 'Move Left';
            leftBtn.style.padding = '3px 6px';
            leftBtn.style.fontSize = '12px';
            leftBtn.style.marginRight = '2px'; // Tighter spacing
            leftBtn.disabled = index === 0;
            leftBtn.onclick = (e) => { e.preventDefault(); moveSankeyDimension(index, 'left'); };

            const rightBtn = document.createElement('button');
            rightBtn.innerHTML = '&#x25B6;'; // Right arrow
            rightBtn.title = 'Move Right';
            rightBtn.style.padding = '3px 6px';
            rightBtn.style.fontSize = '12px';
            rightBtn.disabled = index === window.currentSankeyDimensionsOrder.length - 1;
            rightBtn.onclick = (e) => { e.preventDefault(); moveSankeyDimension(index, 'right'); };

            div.appendChild(checkbox);
            div.appendChild(label);
            div.appendChild(leftBtn);
            div.appendChild(rightBtn);
            container.appendChild(div);
        });
    }

    function renderSavedItemsList() {
        const listElement = document.getElementById('saved-items-list');
        const noItemsMessage = document.getElementById('no-saved-items');
        if (!listElement || !noItemsMessage) return;

        listElement.innerHTML = ''; 

        if (savedItems.length === 0) {
            noItemsMessage.style.display = 'block';
            return;
        }
        noItemsMessage.style.display = 'none';

        savedItems.forEach(item => {
            const listItem = document.createElement('li');
            listItem.style.padding = "5px 0";
            listItem.style.borderBottom = "1px solid #eee";
            listItem.setAttribute('data-id', item.id);
            listItem.setAttribute('data-type', item.type);

            const itemNameSpan = document.createElement('span');
            itemNameSpan.textContent = item.name;
            itemNameSpan.style.fontWeight = "bold";
            itemNameSpan.style.cursor = 'pointer';
            itemNameSpan.title = `Click to add/focus on ${item.name}`;
            
            listItem.appendChild(itemNameSpan);

            if (item.type === 'cluster-with-details' && item.data && item.data.displayDescriptions) {
                const detailsContainer = document.createElement('div');
                detailsContainer.style.marginLeft = "10px";
                detailsContainer.style.fontSize = "11px";
                detailsContainer.style.color = "#555";
                item.data.displayDescriptions.forEach(desc => {
                    const descP = document.createElement('p');
                    descP.style.margin = "2px 0";
                    descP.textContent = "↳ " + desc;
                    detailsContainer.appendChild(descP);
                });
                listItem.appendChild(detailsContainer);
            }
            
            const removeBtn = document.createElement('button');
            removeBtn.textContent = '✖';
            removeBtn.title = "Remove item";
            removeBtn.style.float = 'right';
            removeBtn.style.fontSize = '10px';
            removeBtn.style.padding = '1px 4px';
            removeBtn.style.marginLeft = '5px';
            removeBtn.style.backgroundColor = '#f56565';
            removeBtn.style.color = 'white';
            removeBtn.style.border = 'none';
            removeBtn.style.borderRadius = '3px';
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeSavedItem(item.id);
            });

            listItem.appendChild(removeBtn);
            listElement.appendChild(listItem);
        });
    }

    function _renderSidebarTable(jsonData, page) {
        sidebarTableContainer.innerHTML = ''; // Clear previous content

        if (!jsonData || !jsonData.rows || jsonData.rows.length === 0) {
            sidebarTableContainer.innerHTML = '<p style="text-align: center; padding: 20px; color: #6c757d;">No results found.</p>';
            sidebarTablePagination.style.display = 'none';
            return;
        }

        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const tbody = document.createElement('tbody');
        const headerRow = document.createElement('tr');

        const headers = Object.keys(jsonData.rows[0]);
        headers.forEach(headerText => {
            const th = document.createElement('th');
            th.textContent = headerText;
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);

        const searchQuery = (document.getElementById('sidebarTableSearchInput').value || "").toLowerCase();
        const keywords = searchQuery.split(' ').filter(k => k.trim());

        jsonData.rows.forEach(rowData => {
            const tr = document.createElement('tr');
            headers.forEach(header => {
                const td = document.createElement('td');
                let cellContent = rowData[header] !== null && rowData[header] !== undefined ? String(rowData[header]) : "";
                
                if (keywords.length > 0) {
                    const regex = new RegExp(keywords.map(k => k.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|'), 'gi');
                    td.innerHTML = cellContent.replace(regex, match => `<mark>${match}</mark>`);
                } else {
                    td.textContent = cellContent;
                }
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });

        table.appendChild(thead);
        table.appendChild(tbody);
        sidebarTableContainer.appendChild(table);
        sidebarTableContainer.style.display = 'block';

        const total = jsonData.total;
        if (total > TABLE_PAGE_SIZE) {
            sidebarTablePagination.style.display = 'block';
            const totalPages = Math.ceil(total / TABLE_PAGE_SIZE);
            document.getElementById('sidebarTotalPages').textContent = totalPages || 1;
            document.getElementById('sidebarCurrentPageInput').value = page;
            document.getElementById('sidebarCurrentPageInput').max = totalPages || 1;
        } else {
            sidebarTablePagination.style.display = 'none';
        }
    }

    async function drawTimeline() {
        const timelineCard = document.getElementById('timeline-card');
        const timelineContainer = document.getElementById('timeline-container');
        const resetBtn = document.getElementById('resetTimelineBtn');
        const applyBtn = document.getElementById('applyTimelineBtn');
        
        if (!timelineCard || !timelineContainer || !resetBtn || !applyBtn) return;

        applyBtn.onclick = () => {
            console.log("Apply button clicked. Updating all visualizations.");
            updateAllVisualizations();
        };

        timelineContainer.innerHTML = '';

        try {
            const response = await fetch(`${API_BASE_URL}/timeline_data`);
            if (!response.ok) throw new Error(`HTTP error ${response.status}`);
            let data = await response.json();

            if (!data || data.length < 2) {
                console.warn("Not enough data to draw timeline.");
                timelineCard.style.display = 'none';
                return;
            }

            timelineCard.style.display = 'block';

            const parseDate = d3.isoParse;
            data.forEach(d => {
                d.time = parseDate(d.time);
                d.value = +d.value;
            });

            const margin = { top: 10, right: 30, bottom: 40, left: 50 };
            const width = timelineContainer.clientWidth - margin.left - margin.right;
            const height = 100 - margin.top - margin.bottom;

            const svg = d3.select(timelineContainer).append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            const context = svg.append("g")
                .attr("class", "context")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleTime().range([0, width]);
            const y = d3.scaleLinear().range([height, 0]);

            x.domain(d3.extent(data, d => d.time));
            y.domain([0, Math.max(50000, d3.max(data, d => d.value) || 0)]);

            const area = d3.area().curve(d3.curveStep).x(d => x(d.time)).y0(height).y1(d => y(d.value));

            context.append("path").datum(data).attr("class", "context-area").attr("d", area);
            context.append("g").attr("class", "axis axis--x").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x));
            context.append("g").attr("class", "axis axis--y").call(d3.axisLeft(y).ticks(4).tickFormat(d3.format(".2s")));
            
            const timeFormat = d3.timeFormat("%Y-%m-%d %H:%M:%S");
            const [startDate, endDate] = x.domain();

            context.append("text")
                .attr("x", 0)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "start")
                .style("font-size", "11px")
                .style("fill", "#333")
                .style("font-weight", "500")
                .text(`Start: ${timeFormat(startDate)}`);

            context.append("text")
                .attr("x", width)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "end")
                .style("font-size", "11px")
                .style("fill", "#333")
                .style("font-weight", "500")
                .text(`End: ${timeFormat(endDate)}`);

            const brush = d3.brushX().extent([[0, 0], [width, height]]).on("end", brushended);
            const brushGroup = context.append("g").attr("class", "brush").call(brush);
            
            brushGroup.call(brush.move, x.range());
            window.currentTimeSelection = { startTime: x.domain()[0], endTime: x.domain()[1] };

            function brushended(event) {
                if (!event.sourceEvent) return;
                const selection = event.selection;
                
                if (!selection) {
                    window.currentTimeSelection = { startTime: x.domain()[0], endTime: x.domain()[1] };
                    console.log(`Time window reset to full range.`);
                } else {
                    const [x0, x1] = selection.map(x.invert);
                    window.currentTimeSelection = { startTime: x0, endTime: x1 };
                    console.log(`Time window selection updated: ${x0.toISOString()} to ${x1.toISOString()}`);
                }
            }

            resetBtn.onclick = () => {
                window.currentTimeSelection = { startTime: x.domain()[0], endTime: x.domain()[1] };
                brushGroup.call(brush.move, x.range());
                updateAllVisualizations();
            };

        } catch (error) {
            console.error("Error drawing timeline:", error);
            timelineCard.style.display = 'none';
        }
    }

    async function updateAllVisualizations() {
        showLoading();
        try {
            globalAbortController = new AbortController();
            console.log("Updating all visualizations for new time window...");

            // The order is important: update data models first, then render views
            await Promise.all([updateHeatmap(), updateTimeInfoDisplay()]);
            if (globalAbortController.signal.aborted) throw new DOMException("Aborted");
            
            await loadInlineDendrogram();
            if (globalAbortController.signal.aborted) throw new DOMException("Aborted");

            const sankeyCard = document.getElementById('sankeyCard');
            if (sankeyCard && sankeyCard.style.display !== 'none') {
                await fetchAndRenderSankeyDiagram();
            }

            const ipGraphCard = document.getElementById('packetSimilarityCard');
            if (ipGraphCard && ipGraphCard.style.display !== 'none') {
                await fetchAndRenderLouvainIpGraph();
            }
            
            updateLegend();
            clearSidebarVisualization();
            console.log("All visualizations updated.");

        } catch (error) {
            if (error.name !== 'AbortError') {
                console.error("Error updating visualizations:", error);
                alert("An error occurred while updating views for the selected time range.");
            } else {
                console.log("Visualization update cancelled.");
            }
        } finally {
            hideLoading();
        }
    }

    document.getElementById('entropyMinFilter').style.display = 'none';
    document.getElementById('entropyMaxFilter').style.display = 'none';
    document.querySelector('label[for="entropyMinFilter"]').style.display = 'none';
    document.querySelector('label[for="entropyMaxFilter"]').style.display = 'none';
  </script>
</body>
</html>